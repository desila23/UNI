## Misura di complessitÃ 
Una misura di complessitÃ  Ã¨ una funzione `c` che associa un valore numerico ad una macchina di Turing T e ad un suo input.

>[!tip] `c(T,x)` rappresenta il "costo" della computazione `T(x)`

#### Due proprietÃ  fondamentali da dover rispettare (Assiomi di Blum)
1) `c` Ã¨ **definita per TUTTE E SOLE le computazioni che terminano**
	- anche perchÃ©, se una computazione non termina non ha senso considerare un costo "finito"
2) `c` deve essere **calcolabile**
	- deve esistere una macchina di Turing M che, ricevendo come input una macchina di turing `T` e un suo input `x`, calcola `c(T,x)` ogniqualvolta `c(T,x)` Ã¨ definita (ossia quando `T(x)` termina


---

## Misure deterministiche 
Queste sono misure di complessitÃ  che si riferiscono a computazioni deterministiche.

Quindi
- per ogni macchina di Turing deterministica T (riconoscitore o trasduttore) definita su un alfabeto $\Sigma$
- e per ogni $x \in \Sigma^{*}$
definiamo le due funzioni associate alla computazione `T(x)`
![[Pasted image 20250423174254.png]]

>[!tip] OSSERVAZIONE 
>Le due funzioni sono PARZIALI: non sono definite quando `T(x)` non termina

#### Dimostriamo ora che `dtime` e `dspace` rispettano i due assiomi di Blum
1) ==`c` Ã¨ **definita per TUTTE E SOLE le computazioni che terminano**==
	LO ABBIAMO GIÃ€ DIMOSTRATO IN "OSSERVAZIONE"
	- Per ogni macchina di Turing deterministica `T` e per ogni $x âˆˆ Î£^{*}$, `dtime(T,x)` e `dspace(T,x)` sono definite **se e solo se `T(x)` termina**. 

2) ==`c` deve essere **calcolabile**==
	Partiamo da `dtime`![[Pasted image 20250423175536.png]]
	
>[!example]- Dimostriamo che `dspace` Ã¨ calcolabile
> ### ğŸ”§ Idea
>
Costruiamo una **modifica `U_dspace`** della macchina di Turing universale `U`.
>
>### ğŸ”¹ Modifiche rispetto a `U`
>
>- Aggiungiamo a `U` un nuovo **nastro `Nâ‚…`** che fungerÃ  da **contatore del numero di celle diverse utilizzate** nella computazione di `T(x)`
>- `U_dspace(T, x)` si comporta come `U(T, x)`, **con la differenza che:**
>  - Tiene traccia dellâ€™insieme delle celle di lavoro visitate almeno una volta
>  - Ogni volta che visita **una nuova cella non ancora raggiunta**, scrive un `1` sul nastro `Nâ‚…` e la registra
>  - Alla fine della computazione, il nastro `Nâ‚…` contiene in **unario** il numero di celle di memoria usate da `T(x)`
>
>### ğŸ”š Risultato
>
>- Se `T(x)` **termina**, allora `U_dspace(T,x)` termina e sul nastro `Nâ‚…` câ€™Ã¨ il valore `dspace(T,x)`
>- Quindi **`dspace(T, x)` Ã¨ una funzione calcolabile**
>- Se `T(x)` **non termina**, anche `dspace(T,x)` **non Ã¨ definita** (Ã¨ una funzione parziale)
>
>## âœ… Conclusione
>
La funzione `dspace` soddisfa i due assiomi di Blum e **Ã¨ calcolabile**.


---

## Misure non deterministiche
Queste sono misure di complessitÃ  che si riferiscono a computazioni NON deterministiche.

Quindi
- per ogni macchina di Turing non deterministica NT (riconoscitore pefforza!!) definita su un alfabeto $\Sigma$
- e per ogni $x \in \Sigma^{*}$
- tali che `NT(x)` ACCETTA
definiamo le due funzioni seguenti
![[Pasted image 20250423181352.png]]

>[!tip] OSSERVAZIONE
>Queste due funzioni sono MOLTO PARZIALI, infatti oltre ad essere parziali per natura, le abbiamo definite SOLO PER LE COMPUTAZIONI ACCETTANTI.
>
>Potremmo aggiungere infatti che, se `NT(x)` non accetta, anche quando `NT(x)` termina, abbiamo che
>- `ntime(NT,x)` non Ã¨ definita
>- `nspace(NT,x)` non Ã¨ definita

Questa osservazione guardala nell'ottica
- NT accetta se esiste una computazione deterministica che accetta
- NT rigetta se TUTTE le computazioni deterministiche rigettano

Proviamo quindi a estendere le definizioni di `ntime` e `nspace` a tutte le computazioni che terminano.

Quindi diremo che
- per ogni macchina di Turing non deterministica NT (riconoscitore) definita su un alfabeto $\Sigma$
- e per ogni $x \in \Sigma^{*}$
- tali che `NT(x)` RIGETTA
![[Pasted image 20250423182528.png]]

#### DEFINIZIONE FINALE DI `ntime` e `nspace`
![[Pasted image 20250423182614.png]]

>[!tip] OSSERVAZIONE
>Anche con questa estensione rimangono comunque PARZIALI

>[!example] Dimostra che rispettano gli assiomi di Blum (non mi va ora)


---

### Relazioni tra spazio e tempo
>[!lemma] TEOREMA 6.1 (caso deterministico)
>Sia `T` una macchina di Turing deterministica, definita su un alfabeto $Î£$ (non contenente il simbolo $\square$) e un insieme degli stati `Q`.
>e sia $x âˆˆ Î£^{âˆ—}$ tale che `T(x)` **termina**. Allora, $$\text{dspace(T,x)} \le \text{dtime(T,x)} \le \text{dspace(T,x)} \cdot |Q| \cdot (|\Sigma| + 1)^{\text{dspace(T,x)}}$$

^a43723

L'ultimo termine rappresenta una **stima del numero massimo di configurazioni possibili della macchina**, cioÃ¨ una stima del tempo massimo impiegabile in funzione dello spazio usato.
â†’ **Ã¨ un limite superiore sul tempo**, che dipende:
- dallo **spazio** usato,
- dal numero di **stati** della macchina,
- e dal numero di **simboli** possibili in ogni cella


Dimostriamo il teorema per punti
1) $\text{dspace(T,x)} \le \text{dtime(T,x)}$
	Ãˆ facile
	- se `T(x)` utilizza `dspace(T,x)` celle di memoria, quelle celle devono essere lette per forza di cose
		- e per leggere una cella impiega un'istruzione
	- fine.
	![[Pasted image 20250423193501.png]]

2)  $\text{dtime(T,x)} \le \text{dspace(T,x)} \cdot |Q| \cdot (|\Sigma| + 1)^{\text{dspace(T,x)}}$
	La prof definisce il termine dopo $\le$ come **il numero di stati globali possibili di `T` nel caso in cui non piÃ¹ di `dspace(T,x)` celle del nastro vengano utilizzate dalla computazione `T(x)`**
	Infatti
	- ogni cella del nastro puÃ² contenere un simbolo di $\Sigma$ oppure il blank, e quindi il numero di configurazioni possibili di `dspace(T,x)` celle del nastro Ã¨ $$(|\Sigma| + 1)^{\text{dspace(T,x)}}$$
	- poi, per ognuna di queste configurazioni
		- la testina puÃ² trovarsi su una qualsiasi delle `dspace(T,x)` celle
		- e la macchina puÃ² essere in uno qualsiasi dei `|Q|` stati interni
	
	Chiamiamo questo valore `k(T,x)`, ossia $$k(T,x) = \text{dspace(T,x)} \cdot |Q| \cdot (ğšº +ğŸ)^{\text{ğğ¬ğ©ğšğœğ(ğ“,ğ±)}}$$Ora, ricordiamo che una computazione (deterministica) Ã¨ una successione di stati globali tali che si passa da uno stato globale al successivo eseguendo una quintupla.
	
	Se `T(x)` durasse piÃ¹ di `k(T,x)` passi (<u>SENZA USCIRE DALLE dspace(T,x) celle</u>), allora vuol dire che nella successione di <u>stati globali</u> siamo entrati due volte nello stesso stato.
	![[Pasted image 20250423195411.png|center]]
	Questo perÃ² vuol dire che ora, eseguendo le quintuple e tornando a $SG_{k(T,x)}$, tornerÃ² di nuovo a $SG_{h}$, e cosÃ¬ via ALL'INFINITO.
	
	Ho quindi generato un loop, <u>CHE VA IN CONTRADDIZIONE CON L'IPOTESI CHE TERMINA</u>.


>[!lemma] TEOREMA 6.1 (caso non deterministico)
>Sia `NT` una macchina di Turing non deterministica, definita su un alfabeto $Î£$ (non contenente il simbolo $\square$) e un insieme degli stati `Q`.
>e sia $x âˆˆ Î£^{âˆ—}$ tale che `NT(x)` **accetta/termina**. Allora, $$\text{nspace(NT,x)} \le \text{ntime(NT,x)} \le \text{nspace(NT,x)} \cdot |Q| \cdot (|\Sigma| + 1)^{\text{nspace(NT,x)}}$$
>
NON VA FATTA LA DIMOSTRAZIONE!!!!!!!!!


---


## Verso le classi di complessitÃ 
- Sia $f: \mathbb{N} \rightarrow \mathbb{N}$ una funzione **totale calcolabile** â†’ questa funzione rappresenta il **limite massimo** di tempo o spazio che una macchina puÃ² usare **in base alla lunghezza dell'input**
- Sia $x \in \Sigma^{*}$, e $|x|$ la **lunghezza** di **`x`**

![[Pasted image 20250423202231.png]]âœ… Qui **la macchina termina sempre**, e **accetta o rifiuta** lâ€™input in tempo/spazio limitato da $f(n)$


![[Pasted image 20250423202327.png]]
âš ï¸ Nota bene: qui la macchina **non Ã¨ obbligata a rifiutare i casi negativi**!  
Basta che **esista almeno una computazione accettante** entro il tempo/spazio $f(n)$
###### ğŸ”¹ E se la stringa **non Ã¨ nel linguaggio**?
âŒ Non siamo obbligati a dire **niente**
- La macchina **puÃ² anche non fermarsi mai**
- Oppure puÃ² fermarsi, ma **senza mai accettare**
- Lâ€™importante Ã¨ che **per le stringhe valide ci sia almeno un cammino accettante**


![[Pasted image 20250423202445.png]]
âœ… Qui **tutti i cammini terminano**, e **accettano solo se la stringa Ã¨ nel linguaggio**


---

## Dall'accettazione alla decisione
>[!lemma] Teorema 6.2 (tempo)
>Se un linguaggio $L \subseteq \Sigma^*$ Ã¨ **accettato** da una macchina di Turing **non deterministica** $NT$ **entro tempo** $f(|x|)$, allora **L Ã¨ decidibile**.
##### ğŸ§  Intuizione:
Abbiamo una macchina non deterministica che **accetta** le stringhe in $L$ entro tempo $f(|x|)$,  
ma **non dice nulla** su cosa succede per $x \notin L$ (potrebbe anche non fermarsi mai!).

Il nostro obiettivo Ã¨ **costruire una nuova macchina NTâ€² che decide L**: cioÃ¨ che **termina sempre** e **accetta se e solo se** $x \in L$.

##### ğŸ› ï¸ Strategia della dimostrazione
1. **Costruiamo una macchina $T_f$â€‹** che calcola $f(x)$ in **unario** (cioÃ¨ una stringa di 1 ripetuti)
    - Esempio: se $f(5)=4$, allora $T_f$â€‹ scrive `1111`
    
2. **Costruiamo una nuova macchina NTâ€²**, a **3 nastri**, che decide $L$:
    - Nastro 1: contiene lâ€™input $x$
    - Nastro 2: usato per calcolare $|x|$
    - Nastro 3: conterrÃ  $f(|x|)$ in unario (numero di passi massimi concessi)

##### ğŸ§© PASSAGGI DELLA COSTRUZIONE
###### ğŸ”§ FASE 1: Calcoliamo f(|x|)
1. $NT'$ prende in input `x`.
2. Scrive $|x|$ (la lunghezza di x) su un nastro.
3. Chiede a una macchina calcolatrice $T_f$â€‹ di calcolare $f(|x|)$ e scriverlo in **unario** su un altro nastro (questo qui sarÃ  il tempo massimo utilizzabile)

###### ğŸ”§ FASE 2: Simuliamo $NT(x)$
1. $NT^{â€²}$ **simula** $NT$ su input `x`.
2. Ogni volta che fa una mossa della simulazione, **cancella un `1`** dal nastro dove c'Ã¨ f(|x|).
3. Se:
    - $NT(x)$ accetta â†’ anche $NT^{â€²}(x)$ accetta.
    - $NT(x)$ rigetta â†’ anche $NT^{â€²}(x)$ rigetta.
    - Finisce il tempo (il nastro Ã¨ vuoto, ma $NT$ non ha ancora terminato) â†’ $NT^{â€²}$ **rigetta**.

> Quindi $NT^{â€²}$ simula il comportamento di $NT$, ma si ferma dopo f(|x|) passi.

###### ğŸ’¡ E quindi? Cosa abbiamo ottenuto?
âœ… Se `x âˆˆ L`, allora:
- Esiste un ramo in cui la macchina `NT` accetta `x` entro `f(|x|)` passi
- La macchina `NT'` simula `NT` â†’ quindi anche `NT'` accetta

âœ… Se `x âˆ‰ L`, allora:
- `NT` non accetta mai entro `f(|x|)` passi
- `NT'` quindi rigetta perchÃ©:
  - o simula e vede che `NT` rigetta
  - oppure finisce il tempo (nastro finito) e rigetta comunque

###### â“ Ma... c'Ã¨ un problema?
> Quanto tempo impiega `NT'` per calcolare `f(|x|)`?
- Non lo sappiamo!
- Sappiamo solo che **termina**, perchÃ© `f` Ã¨ **totale calcolabile**
- Ma **non possiamo sapere quanto tempo impiega**

###### âœ… Conclusione
- La macchina `NT'` **decide** il linguaggio `L` (cioÃ¨ **termina sempre** e dÃ  una risposta corretta)
- âŒ **Non possiamo dire** che lo decide **in tempo `f(n)`**, perchÃ© non sappiamo quanto tempo ci vuole per calcolare `f(n)`

###### ğŸ”š Quindi:

ğŸŸ¢ `L` Ã¨ **decidibile**  
ğŸŸ¡ Ma **non necessariamente** in **tempo `f(n)`**


>[!lemma] Teorema 6.2 (spazio)
Sia `f : â„• â†’ â„•` una **funzione totale calcolabile**.  
Se un linguaggio `L âŠ† Î£*` Ã¨ **accettato da una macchina di Turing non deterministica** `NT` tale che, per ogni `x âˆˆ L`, vale: `nspace(NT, x) â‰¤ f(|x|)` -> allora `L` Ã¨ **decidibile**.
>
Dimostrazione analoga e non va fatta!


---

### ComplessitÃ  e modelli di calcolo
Esiste una regola che dice "tutti i modelli di calcolo deterministici, tra loro, sono ***polinomialmente correlati***"

##### ğŸ§  Cosa significa â€œpolinomialmente correlatiâ€?
Significa che **le differenze tra i modelli non cambiano â€œtroppoâ€ lâ€™efficienza**.

PiÃ¹ precisamente:
> Se una macchina di Turing `T` risolve un problema in tempo `t(n)`, allora **possiamo costruire unâ€™altra macchina `Tâ€™` di un modello diverso** che risolve lo stesso problema in **tempo al massimo `p(t(n))`**, dove `p` Ã¨ un **polinomio**.

Quindi abbiamo che $$ \text{dtime(Tâ€™,x)} â‰¤ p\text{( dtime(T,x) )}$$ e $$\text{dspace(Tâ€™,x)} â‰¤ p\text{( dspace(T,x) )} $$
###### ğŸ¤– Esempi di modelli considerati:
- Macchina di Turing **ad un solo nastro**
- Macchina di Turing **con piÃ¹ nastri**
- Macchina con **alfabeto binario**
- Macchina con **alfabeto piÃ¹ grande**

> Il modello **Macchina di Turing Ã¨ polinomialmente correlato con il PascalMinimo**.

>[!question] PerchÃ© Ã¨ utile?
>PerchÃ© possiamo risolvere un problema utilizzando il modello di calcolo che piÃ¹ ci aggrada.
> 
>Ad esempio, per risolvere un certo problema possiamo scrivere un algoritmo A in PascalMinimo (invece che stare lÃ¬ a progettare quintuple di una macchina di Turing) 
>- e se A trova la soluzione di una istanza x del problema eseguendo f(|x|) istruzioni 
>- allora esiste una macchina di Turing T ad un nastro che risolve lo stesso problema, ed esiste un polinomio p tale che $\text{dtime(T,x)} â‰¤  p( f(|x|)$

