## IntroÂ 
Fino ad ora nel nostro modello irreale:Â 
- Tutti i router identici tra soloÂ 
- Rete piatta, tutti i router vedono la rete come un unico livello senza gerarchieÂ 

In un contesto reale:Â 
- Non si possono salvare tutte le destinazioni nelle tabelle di routing (altrimenti avremo tabelle troppo grandi);Â 
- Gli scambi tra le tabelle di routing occuperebbero un tempo enorme intasando la rete;Â 
- Gli algoritmi studiati sono troppo lenti per reti cosÃ¬ grandi;Â 
- Internet Ã¨ una **rete di reti**;Â 
- Ogni amministratore ISP vuole gestire il routing nella sua parte di rete.Â 


## Routing "scalabile"Â 
Per gestire in modo scalabile lâ€™instradamento su Internet, che Ã¨ una rete vastissima e distribuita, si adotta una strategia che consiste nel suddividere lâ€™intera rete in **sistemi autonomi** (noti come **AS â€“ Autonomous Systems**).
Un sistema autonomo Ã¨ un insieme di router che appartengono alla stessa amministrazione e sono sotto il controllo di unâ€™unica entitÃ  (come un provider Internet o unâ€™azienda).

Due tipi di instradamento (routing):Â 
1) **Intra AS (o intra domain)**, routing dentro un AS:Â tutti i router dello stesso AS usano lo stesso protocollo per comunicare tra loro.
	Ãˆ importante notare che **AS diversi possono usare protocolli diversi**, proprio perchÃ© ogni AS Ã¨ indipendente e puÃ² scegliere il sistema piÃ¹ adatto alle proprie esigenze. 
	Per questo esiste il concetto di **router gateway**: si tratta di router che si trovano **ai confini dellâ€™AS** e che si occupano di comunicare con router appartenenti ad altri AS. Questi router gateway fungono da ponte tra il routing interno e quello esterno.

2) Inter AS (o inter domain), routing tra AS diversi:Â Il routing inter-AS riguarda invece la comunicazione **tra sistemi autonomi differenti**. Ãˆ gestito dai **gateway router** che sono responsabili di determinare **come raggiungere reti esterne allâ€™AS**, ovvero decidere attraverso quali altri AS passare per arrivare a una destinazione remota.

#### Esempio
Abbiamo 3 AS, ogni AS ha i propri router
![[GetImage - 2025-05-02T142942.128.png|center]]

I router dentro un AS comunicano solo tramite **intra-AS**
![[GetImage - 2025-05-02T143051.053.png|center]]

I gateway router sono quelli che collegano i vari AS tra loro (connessioni Inter-AS)Â 
![[GetImage - 2025-05-02T143157.475.png|center]]


## AS-interconnessiÂ 
![[GetImage - 2025-05-02T143221.642.png|center]]
 Ogni router ha una tabella di inoltro riempita usando 
 - gli **algoritmi di intra-AS** per decidere come raggiungere i routerÂ dentro lo stesso ASÂ 
 - e **inter-AS** per decidere come raggiungereÂ destinazioni fuori dallâ€™AS.Â 
	- Se un pacchetto deve restare dentro l'AS ->Â AS-routingÂ 
	- Se deve uscire verso un altro AS â†’ servonoÂ entrambiÂ intra e inter AS.Â 

##### Esempio di situazione:Â 
- Un router diÂ AS1Â riceve un datagramma destinato a una reteÂ fuori da AS1.Â 
- Il router deve mandare il pacchetto a unÂ router gatewayÂ in AS1 ma non sa qualeÂ 
![[GetImage - 2025-05-02T143420.673.png|center]]
- L'instradamento inter-AS inÂ AS1 deve imparare quali destinazioni sono raggiungibili attraverso AS2 e quali attraverso AS3 eÂ dare queste informazioni a tutti i router in AS1Â 


#### Protocolli di instradamento intra-ASÂ 
1. **RIP - routing information protocol**Â 
	Ãˆ di tipo distance vector (DV), i router scambiano tabelle ogni 30 secondi.Â NON SI USA PiÃ¹Â 

2. EIGRPÂ â€“Â Enhanced Interior Gateway Routing ProtocolÂ 
	Basato su DV, usato nelle reti CiscoÂ Â 

3. OSPF â€“ Open Shortest Path FirstÂ 
	Di tipo Link State, ogni router costruisce una mappa della rete e scambia informazioni solo se ci sono modifiche nella rete.Â Usato nelle reti moderne.Â Questo protocollo Ã¨ identico a IS-IS (Ã¨ una nota nelle slide)Â 


## OSPFÂ 
Ogni router manda informazioni sullo stato dei suoi collegamenti a tutti gli altri router dell'AS, in broadcast,Â usando direttamente IPÂ e non TCP/UDP. 
PuÃ² usare piÃ¹ criteri per valutare il costo di un collegamento come la larghezza di banda e il ritardo.Â Ogni router conosce tutta la rete e calcola i percorsi usando lâ€™algoritmo di Dijkstra per creare la propria tabella di inoltro.Â 
Inoltre tutti i messaggi sono autenticati per sicurezza.Â 

OSPF ha una gerarchia a due livelli:Â 
1. Area locale:Â un sottoinsieme della reteÂ 
2. Backbone (dorsale) :Â collega tutte le aree tra loroÂ 

Ogni router conosce beneÂ soloÂ la sua area e le direzioni per raggiungere le altre destinazioni (non i dettagli interni).Â 
![[GetImage - 2025-05-02T143722.424.png]]
Questa immagine mostra come funziona la gerarchia in OSPF con piÃ¹ aree e il backbone (dorsale).Â Â 

La rete Ã¨ divisa in aree (1,2,3) e tutte sono collegate alla dorsale (backbone):Â 
- Router locali:Â operano solo dentro la loro area, calcolano l'instradamento interno e per inoltrare i pacchetti all'esterno usano i router di confine d'areaÂ 
    
- Router di confine d'area:Â collegano una o piÃ¹ reti al backbone, ricevono le informazioni di routing da tutti i router della propria area e ne inviano una versione "semplificata" alla dorsale. Inoltrano i pacchetti che devono uscire dall'area.Â 
    
- Router di dorsale (backbone):Â esegue OSPF solo nella dorsaleÂ 
    
- Router di confine:Â collega l'AS ad altri ASÂ 
	
- Instradamento Internet inter-AS: BGPÂ 


## BGPÂ 
Ãˆ il protocollo standard per l'instradamento inter-domain, permette ai vari AS di comunicare tra solo (*la colla di internet*).Â 

Permette ad un AS di comunicare la sua esistenza e tutte le destinazioni che puÃ² raggiungere al resto di Internet.Â 

BGP fornisce a ciascun AS un mezzo per:Â 
1. eBGP:Â 
	Riceve info dai vicini (altri AS) su quali reti sono raggiungibiliÂ 

2. Policy e decisioni:Â Â 
	Scegliere quali rotte usare per raggiungere altre reti in base a costi e varie politicheÂ 

3. iBGP:Â 
	Diffondere le informazioni di raggiungibilitÃ  dentro il proprio AS, a tutti i router interniÂ 

4. Annunci:Â 
	Comunicare alle reti vicine quali destinazioni puÃ² offrire lui stessoÂ 

![[GetImage - 2025-05-02T143935.019.png|center]]
- Le connessioni blu sono logiche, interne allo stesso AS e servono per far arrivare a tutti i router dell'AS le informazioni ricevute daÂ ebpg.Â 
	- Ad esempio in AS1, 
		- il routerÂ 1cÂ riceve info da AS2 
		- e le comunica agli altri router di AS1 (1a, 1b, 1d) tramiteÂ iBGP.Â Â 

- I router cerchiati sono di gateway ed eseguono entrambi i protocolli, 
	- eBGP per parlare con altri AS
	- iBGP per aggiornare i router interni.Â 


## Sessione BGPÂ 
Ãˆ una **connessione TCP** (semi permanente) tra **due router BGP** (detti **peers**) e serve per scambiarsi informazioni sui percorsi
![[GetImage - 2025-05-02T144606.434.png|center]]

### Messaggi del protocollo BDP
I **messaggi del protocollo BGP** (Border Gateway Protocol), che sono scambiati tra router **peer** tramite connessioni **TCP**.
###### âœ… **OPEN**
- Serve per **iniziare la connessione BGP** tra due peer.
- Autentica il peer remoto.
- Ãˆ il **primo messaggio** che viene scambiato dopo che la connessione TCP Ã¨ stabilita.
###### ðŸŸ¥ **UPDATE**
- Ãˆ il messaggio **piÃ¹ importante** del BGP.
- Serve per:
    - **Annunciare nuovi percorsi** (es. â€œper raggiungere la rete X, passa da meâ€).
    - **Ritirare vecchi percorsi** non piÃ¹ validi.
- Ãˆ quello che effettivamente aggiorna le informazioni di instradamento.
###### ðŸ”µ **KEEPALIVE**
- Serve a **mantenere viva** la connessione quando non ci sono UPDATE da inviare.
- Funziona anche come **ACK (conferma)** per lâ€™OPEN ricevuto.
- In pratica: "Sono ancora vivo, tutto ok."
###### ðŸŸ¡ **NOTIFICATION**
- Indica che câ€™Ã¨ stato **un errore** (es. messaggio malformato, autenticazione fallita).
- PuÃ² anche essere usato per **chiudere la connessione** in modo esplicito.


### Attributi dei percorsi e rotte BGP
###### ðŸ§  Contesto generale: cos'Ã¨ una "rotta" per BGP
Quando un router BGP vuole **dire agli altri router che puÃ² raggiungere una certa rete**, invia un **annuncio di rotta**: **annuncia un prefisso**, cioÃ¨ una rete (es. `10.0.0.0/8`), e allega una serie di **attributi** che aiutano gli altri router a decidere **se e come** usare quel percorso.

###### ðŸ“¦ Cosa contiene una rotta BGP?
Una **rotta BGP** Ã¨ composta da:
1. **Prefisso** â†’ rappresenta la **rete di destinazione** (es. a chi voglio inviare i pacchetti).
    
2. **Attributi** â†’ informazioni aggiuntive, come:
    - **AS-PATH**: Ã¨ una lista di numeri di AS (es. `[AS1, AS3, AS7]`) che rappresenta tutti gli Autonomous Systems attraversati dal percorso.  
    - **NEXT-HOP**: Ã¨ lâ€™indirizzo IP del router verso cui devo **effettivamente inviare i pacchetti** per raggiungere la rete.  

##### ðŸ§­ Come viene usata una rotta? (Routing basato su politiche)
Nel BGP, non basta ricevere una rotta per usarla. Ogni **AS applica delle regole interne (politiche)** per decidere cosa fare con le rotte ricevute e annunciate.

Due tipi di politiche:
- **Import policy** â†’ decide se **accettare** o **rifiutare** una rotta ricevuta.  
    Esempio: un AS puÃ² decidere di non fidarsi di un certo AS (tipo `AS Y`) e quindi **rifiutare tutti i percorsi che passano da Y**, anche se sono piÃ¹ corti.
    
- **Export policy** â†’ decide **quali rotte annunciare** ai vicini.  
    Esempio: un AS puÃ² **evitare di annunciare certe destinazioni** a certi AS, per motivi di sicurezza, commercio o performance.

âš ï¸ Quindi BGP **non cerca sempre il percorso piÃ¹ breve**, ma **il piÃ¹ adatto secondo le regole locali di ogni AS**.


## Annuncio di percorso BGP
![[Pasted image 20250502150726.png]]
- Hai 3 Autonomous Systems (AS1, AS2, AS3), ciascuno con i suoi router.
	- Nel **AS3** câ€™Ã¨ una rete chiamata **X** che vogliamo raggiungere.

- Il router **3a** in AS3 annuncia che â€œpuÃ² raggiungere Xâ€ â†’ questo Ã¨ lâ€™annuncio BGP iniziale.

![[Pasted image 20250502150950.png]]

### Annuncio di percorso BGP: percorsi multipli
![[Pasted image 20250502151514.png]]
Stessa situazione di prima, ma
- Il router **1c** in AS1 Ã¨ un **gateway BGP** che riceve due annunci di rotta.
![[Pasted image 20250502151625.png]]

>[!question]- E cosa succede una volta presa la decisione?
>Ipotizziamo che passi per `AS3`.
>Ora il router `1c` deve **informare gli altri router di AS1** e questi devono **sapere dove inoltrare i pacchetti diretti a X**.
>##### ðŸ§© Cosa succede?
>###### ðŸ”¹ 1. Propagazione con iBGP
>- Il router **1c**, che ha ricevuto lâ€™annuncio da AS3, **propaga questa informazione via iBGP** a tutti i router interni dellâ€™AS1 (come 1a, 1b, 1d).
>    
>- I router interni **non imparano direttamente il NEXT-HOP finale (AS3)**, ma solo che:
>    
    > â€œPer raggiungere la rete X, devi passare da me (1c)â€.
>###### ðŸ”¹ 2. Aggiornamento delle tabelle di inoltro
>
>Prendiamo ad esempio il router **1d**:
>
>- Riceve da 1c, via iBGP, lâ€™informazione: â€œvai verso X passando da 1câ€.
>    
>- Per raggiungere 1c, **1d usa OSPF** (o un altro protocollo di routing interno).
>    
>- OSPF gli dice: â€œper arrivare a 1c, usa lâ€™**interfaccia 1**â€.
>
>â†’ Quindi la **tabella di inoltro di 1d** avrÃ  una voce del tipo:
>```yaml
>Destinazione: X
Prossimo hop: 1c
Interfaccia: 1
>```
>
>Incollo qui le slide per farti capire anche visivamente
>![[Pasted image 20250502152832.png]]
>![[Pasted image 20250502152850.png]]


## Instradamento a patata bollente (hot potato routing)
Ãˆ una **strategia di instradamento intra-AS** in cui:
> Ogni router cerca di **liberarsi il prima possibile del traffico**, **passandolo al primo gateway disponibile** verso un altro AS, **anche se non Ã¨ il percorso globale piÃ¹ corto**.

![[Pasted image 20250502153449.png]]
- Il router **2d**, in **AS2**, ha appreso via **iBGP** che puÃ² raggiungere la rete **X** in **AS3**.
- PuÃ² farlo tramite:
    - Il gateway **2a**
    - Oppure il gateway **2c**
    
- Entrambi hanno una rotta valida verso X, quindi 2d **deve decidere a chi passare la â€œpatataâ€** (il traffico per X).

##### ðŸ” Come sceglie?
Nel **hot potato routing**, 2d **non si chiede qual Ã¨ il percorso migliore verso X**, ma:
> â€œQuale dei miei colleghi (gateway) Ã¨ piÃ¹ vicino a me all'interno del mio AS?â€

Nel caso della foto:
- Distanza intra-AS tra 2d â†’ 2a: costo 201
- Distanza intra-AS tra 2d â†’ 2c: costo 263
â†’ **sceglie 2a**, anche se passando da 2c il traffico magari avrebbe fatto meno hop globali verso X.

##### ðŸ’¡ PerchÃ© funziona cosÃ¬?
- Ogni AS vuole **minimizzare i propri costi interni** (infrastruttura, banda, gestione).
- Non gli interessa **quanto il pacchetto ci mette a destinazione**, ma **liberarsene il prima possibile**.
- Questo approccio:
    - Riduce il carico interno allâ€™AS
    - Ma puÃ² **aumentare il numero totale di hop** o **il ritardo end-to-end**


## ðŸŒ BGP: implementare le politiche attraverso gli annunci
Qui parliamo di **BGP nel mondo reale**, dove gli AS (come B e C) possono essere **provider** (ISP) e hanno **clienti** (come A).  

Lâ€™**obiettivo degli ISP** Ã¨:
> âœ‹ Non trasportare traffico tra due altri ISP se non sono direttamente coinvolti.  
> (CioÃ¨: â€œnon voglio essere il taxi per far viaggiare traffico tra due non-clientiâ€)

Questa Ã¨ una **politica commerciale tipica**, perchÃ© trasportare traffico ha un costo, e lo si fa solo per i propri clienti.

![[Pasted image 20250502155930.png]]
1. La rete **A** annuncia, tramite BGP, la propria **raggiungibilitÃ ** (`Aw`) ai suoi provider: **B** e **C**.
    
2. Il nodo **B** riceve lâ€™annuncio `Aw` e, **per policy**, **decide di non inoltrarlo a C**.
    - In pratica, **B non annuncia il percorso `BAw` a C**.
    
3. Il nodo **C** non viene mai a sapere che puÃ² raggiungere `w` passando da B â†’ A.
    - Quindi non potrÃ  usare il percorso **C â†’ B â†’ A â†’ w (`CBAw`)**.
    
4. Di conseguenza, **C dovrÃ  usare il percorso diretto C â†’ A â†’ w**, **senza passare da B**.

(diciamo che questo esempio non aiuta molto a capire, ma immagina che il collegamento diretto **C -> A** non possa essere usato per un qualche motivo; se `B` non annuncia a **C** che esiste il percorso `BAw`, **C** rimane inculato)


##### ðŸ§  Punto chiave: **le politiche le puÃ² imporre anche un _cliente_**!
![[Pasted image 20250502160220.png]]Ora il **protagonista Ã¨ x**, una **rete cliente** collegata sia a **B** che a **C** â†’ si dice **dual-homed**.
- La rete **x** Ã¨ cliente di **B** e **C**.
- Tuttavia, anche se Ã¨ un cliente, **x puÃ² decidere che non vuole fungere da ponte** tra due provider.

In pratica:
> â€œNon voglio che B usi me (x) per parlare con C, o viceversaâ€.

##### ðŸ§© Come si realizza questo?
x **applica una policy BGP** e **non annuncia a B i percorsi ricevuti da C**.
Risultato:
- B **non saprÃ ** che c'Ã¨ una rotta verso C **attraverso x**.
- Quindi **non potrÃ  inoltrare traffico verso C passando da x**.
- x si protegge dal diventare un **transit network gratuito** tra due grandi ISP.

### ðŸ§­ Quando ci sono piÃ¹ percorsi validi, **come sceglie BGP?**
Un router puÃ² conoscere **piÃ¹ annunci per la stessa rete di destinazione** (es. per raggiungere `X`). Ma BGP **non usa tutti i percorsi** contemporaneamente: ne sceglie **uno solo**.

La scelta segue un **ordine preciso di prioritÃ **, **basato su attributi** del protocollo BGP.  
Abbiamo **4 criteri**, in ordine:
1. **Preferenza locale (Local Preference)** âœ…
	- Ãˆ un valore interno allâ€™AS, impostato in base a **decisioni politiche o commerciali**.
	- PiÃ¹ alto = **piÃ¹ preferito**.
	- Esempio: â€œPreferisco passare dal mio cliente (pagante) piuttosto che da un providerâ€.
	 ==Questo Ã¨ il **criterio piÃ¹ importante**, perchÃ© **riflette le scelte amministrative dellâ€™AS**.==

 2. **AS-PATH piÃ¹ breve** ðŸ”
	- Tra due rotte equivalenti, si sceglie quella con il **minor numero di AS attraversati**.
	- Utile per evitare percorsi piÃ¹ lunghi (e possibilmente instabili).
	==Se i local-pref sono uguali, BGP cerca il **percorso â€œpiÃ¹ direttoâ€ a livello di AS**.==

 3. **NEXT-HOP piÃ¹ vicino (Hot Potato Routing)** ðŸ¥”
	- Se i primi due criteri non sono discriminanti, il router **sceglie il gateway piÃ¹ vicino a sÃ©**, **dentro lâ€™AS**.
	- In pratica: â€œliberami del pacchetto il prima possibileâ€.
	==Questo Ã¨ lâ€™approccio hot potato routing: **minimizza i costi interni**, anche se il percorso totale Ã¨ meno ottimale.==

 4. **Identificatori BGP (router ID)** ðŸ”¢
	- Se anche tutto il resto Ã¨ identico, si sceglie il router con lâ€™**ID numericamente piÃ¹ basso** (generalmente lâ€™IP piÃ¹ piccolo).
	- Questo criterio **serve solo a rompere i pareggi** quando tutto Ã¨ uguale.


>[!question]- ðŸ‘‰ _PerchÃ© esistono due tipi distinti di instradamento, intra-AS e inter-AS, invece di uno solo?_
>##### ðŸ” **1. Politiche**
>- **Inter-AS**: ogni AS Ã¨ **amministrato in modo indipendente**
>    â†’ Ogni amministratore **vuole controllare come e da chi viene raggiunto**, e **decidere chi puÃ² usare la propria rete** per inoltrare traffico.
>- **Intra-AS**: tutto Ã¨ **sotto unâ€™unica amministrazione** (es. unâ€™azienda o un'universitÃ ).  
>    â†’ Quindi **non ci sono conflitti di interesse**: tutti i router collaborano e **non serve negoziare** politiche.
> 
> ##### ðŸ“ˆ **2. ScalabilitÃ **   
> Il routing gerarchico consente di ridurre le dimensioni delle tabelle e il traffico di aggiornamento.
> 
> ##### âš¡ **3. Prestazioni**
> - Intra-AS: si puÃ² ottimizzare l'instradamento per **massimizzare le prestazioni**
> - Inter-AS: le **politiche vincono sulle prestazioni**


---

# Software defined networking (SDN)Â 
- Controllo distribuito: ogni router prende decisioni in autonomia.Â 
- IÂ router monolitici: hanno hardware + software proprietario, gestiscono tutti i protocolli (IP, OSPF, BGP, ecc.) in un solo blocco.Â 

DalÂ 2005Â circa, Ã¨ cresciuto lâ€™interesse nelÂ ripensare il piano di controllo della rete, portando allâ€™idea di separare controllo e forwarding (il moderno SDN)

#### Modello tradizionale Vs SDN
Nel modello tradizionale ogni router ha il **proprio algoritmo di instradamento** e una **tabella di forwarding locale**
![[GetImage - 2025-05-02T163406.725.png]]

Con SDN il **controllo Ã¨ centralizzato in un controller remoto**, i router non calcolano nulla perchÃ© ricevono direttamente le **tabelle di inoltro** dal controllo diventando dei semplici esecutori (chiamati spesso ***switch SDN***).
![[GetImage - 2025-05-02T164130.842.png]]

#### Casi in cui Ã¨ meglio usare SDN
##### CASO 1
![[GetImage - 2025-05-02T164205.217.png]]
L'operatore vorrebbe che il traffico daÂ `u` a `z`Â passi per il percorsoÂ **u â†’ v â†’ w â†’ z**Â (`uvwz`),Â ma lâ€™algoritmo sceglieÂ **u â†’ x â†’ y â†’ z**Â (`uxyz`) perchÃ© ha peso totale piÃ¹ basso. 
Per cambiare il percorso, lâ€™unico modo Ã¨Â modificare manualmente i pesi dei link.

##### CASO 2
![[GetImage - 2025-05-02T164401.826.png]]
L'operatore vuole dividere il traffico daÂ `u` a `z`Â traÂ **due percorsi**,Â `uvwz` e `uxyz`.Â 
Non si puÃ² fare, a meno di usare un nuovo algoritmo di routing.

##### CASO 3
![[GetImage - 2025-05-02T164532.233.png]]Se il routerÂ `w`Â volesseÂ **instradare il traffico blu e quello rosso su percorsi diversi**Â daÂ `w` a `z`?Â 
Non puÃ² farlo, se il routing Ã¨ basato solo sullaÂ **destinazione**, **tutto il traffico verso zÂ segue laÂ stessa rotta**.


### SDN
![[GetImage - 2025-05-02T164742.572.png]]
1. Inoltro generalizzato "basato sui flussi"Â 
    - Es. OpenFlow: il controller decide come gestire ogni flusso di pacchetti, non solo in base alla destinazione.Â 
    
2. Separazione tra piano di controllo e piano dei datiÂ 
    - Gli switch/router si occupano solo di inoltrare.Â 
    - Le decisioni vengono prese da un controller centrale.Â 
    
3. Funzioni di controllo esterneÂ 
    - Routing, access control, bilanciamento del carico... sono gestiti fuori dagli switch.Â 
    
4. Applicazioni programmabiliÂ 
    - Si possono scrivere app che controllano la rete (es. per routing dinamico, sicurezza, ottimizzazione).


### ðŸ”½ Cosa fanno gli **switch del piano dei dati**?
GliÂ **switchÂ SDN** sono semplici e veloci, non prendono decisioni; la tabelle di inoltro sono calcolate e installate dal controller.Â Â 

La comunicazione tra controller e switch usa API standard tipoÂ **Open Flow**Â che definisce cosa Ã¨ controllabile da remoto.Â 

Il **controller SDN**Â ha molteplici funzioni:Â 
- **Mantiene lo stato della rete**: conosce topologia, traffico, link attiviâ€¦Â 
- **Parla con le app di rete**Â (es. routing, access control) tramite leÂ **API northbound**, ovvero le interfacce che il controller SDN usa per parlare con le applicazioni di controlloÂ 
- **Parla con gli switch SDN**Â tramite leÂ **API southbound**Â (es. OpenFlow), ovvero le interfacce che il controller usa per parlare con switch e routerÂ 
- ÃˆÂ **distribuito**, per migliorare le prestazioni, garantire scalabilitÃ  e gestire guasti/sicurezza.Â 

Le applicazioni di controllo di rete decidono come la rete deve comportarsi (routing, bilanciamento del carico eccâ€¦) e usano le API Northwood per comunicare col controller SDN.


### Componenti di un controller SDN
Il controller ha tre livelli principali

![[GetImage - 2025-05-02T171738.607.png|center]]
1. **Interfaccia verso le applicazioni (northbound API)**
	- Ãˆ la parte **piÃ¹ alta** del controller.
	- Serve per collegarsi a **applicazioni di rete** (es. routing, access control, load balancingâ€¦).
	- Usa **API** (es. RESTful API) e astrazioni (come `intent`, `network graph`).
	 ==Ãˆ la parte che rende SDN **programmabile** da software esterno.==

2. **Gestione dello stato della rete**
	Questa Ã¨ la **memoria centrale della rete**: tiene traccia di tutto.
	- **Statistics**: dati di traffico e prestazioni.
	- **Flow tables**: regole per lâ€™inoltro.
	- **Link-state info**: lo stato dei collegamenti (attivi? guasti?).
	- **Host info**: chi Ã¨ connesso e dove.
	- **Switch info**: configurazione e stato degli switch.
	==Ãˆ un vero e proprio **database distribuito**, aggiornato continuamente.==

3. **Comunicazione con gli switch (southbound API)**
	- Ãˆ la parte piÃ¹ **vicina allâ€™hardware**.
	- Serve per **ricevere dati dalla rete** e **mandare comandi** agli switch.
	- Usa protocolli come:
	    - **OpenFlow** (il piÃ¹ noto)
	    - **SNMP** (per statistiche e configurazione)


### Protocollo OpenFlow
Ãˆ un **protocollo di comunicazione tra controller e switch SDN**.Â 

![[Pasted image 20250502172855.png|center]]

Caratteristiche:Â 
UsaÂ TCPÂ per inviare i messaggi (opzionalmente cifrati); questi si dividono i 3 categorie:Â 
1. **Controller-to-switch**: es. installa o aggiorna una regola.Â 
2. **Asynchronous**: lo switch avvisa il controller (es. nuovo flusso, errore).Â 
3. **Symmetric**: generici, usati da entrambi (es. keepalive).Â 

>[!problem] Non va confuso con l'**API Open Flow** 
>Lâ€™API serve per specificare **cosa vuoi che succeda nella rete**, ma Ã¨ il **protocollo OpenFlow** che **traduce tutto in comandi concreti** agli switch.

#### Messaggi chiave controller-to-switch
| Messaggio      | Scopo principale                                    | **Cosa accade**                                                                                                 |
| -------------- | --------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| `features`     | Conoscere lo switch                                 | Il controllore interroga le caratteristiche dello switch -> lo switch risponde                                  |
| `configure`    | Impostare opzioni di comportamento                  | Il controller **imposta o legge** i parametri di configurazione dello switch.                                   |
| `modify-state` | Gestire la tabella di flusso (inoltro)              | Il controller **aggiunge, modifica o cancella** regole nella **flow table** dello switch.                       |
| `packet-out`   | Inviare direttamente un pacchetto tramite lo switch | l controller invia **direttamente un pacchetto a uno switch** e gli dice:  <br>â€œMandalo fuori da questa portaâ€. |
#### Messaggi chiave switch-to-controller
| Messaggio      | Quando si usa                         | Cosa accade                                                                             |
| -------------- | ------------------------------------- | --------------------------------------------------------------------------------------- |
| `packet-in`    | Nessuna regola corrisponde            | Lo switch **invia un pacchetto al controller** perchÃ© **non sa cosa farne**.            |
| `flow-removed` | Timeout o cancellazione di una regola | Lo switch **avvisa il controller** che una regola Ã¨ stata **rimossa dalla flow table**. |
| `port-status`  | Cambio su una porta fisica            | Lo switch **informa il controller** che Ã¨ avvenuto un **cambiamento su una porta**.     |

>[!tip] Gli operatori di reteÂ non usano direttamente questi messaggi.Â 
UsanoÂ interfacce astratte, piÃ¹ semplici, offerte dal controller (es. API REST).


#### Esempio di interazione tra piano dati e piano di controllo

![[GetImage - 2025-05-02T175742.478.png|center]]
1. S1 rileva un **guastoÂ su una porta di collegamento** e manda un messaggioÂ `port-status` OpenFlowÂ al controller SDN;Â 
2. IlÂ **controller riceve il messaggio**, aggiorna le informazioni sullo stato del collegamento;Â 
    
3. L'applicazione dell'**algoritmo diÂ routing** (es. Dijkstra)Â viene avvisata del cambiamento, in precedenza si era registrata per poter essere avvisata;Â 
    
4. L'app accede alle informazioni e calcola nuovi percorsi in base a quello che Ã¨ cambiato

![[GetImage - 2025-05-02T180029.831.png|center]]
5. L'applicazione di link state routing interagisce col componenteÂ *flow table computation*Â che calcola che nuove flow table da applicare;Â 
    
6. Il controller usa OpenFlow per inviare nuove regole agli switch interessati che necessitano di aggiornamento

==In sintesi SDN permette di aggiornare la rete in modo molto rapido e centralizzato.==


## Controller ODL e ONOD
#### OpenDayLight (ODL)
![[GetImage - 2025-05-02T180242.864.png|center]]
- Usa varie API per comunicare con le applicazioniÂ 
- Ha unaÂ **Service Abstraction Layer** (**SAL**)Â che collega moduli interni e protocolli esterniÂ 
- Supporta vari protocolli southbound tipoÂ Open Flow

#### ONOS
![[GetImage - 2025-05-02T180335.825.png|center]]
- Progettato con unÂ **core distribuito**Â 
- Le API northbound usano il concetto diÂ **Intent**: lâ€™app specificaÂ ***cosa***Â vuole ottenere, ***nonÂ come***.Â 
- Fortemente orientato aÂ **prestazioni e resilienza**Â (repliche, bilanciamento, fault tolerance).Â 
- Anche lui supporta protocolli come OpenFlow

![[GetImage - 2025-05-02T180442.141.png]]

## ConclusioniÂ 
SDN affronta varie sfide:Â 
- Robustezza e sicurezzaÂ del piano di controllo:Â Deve essereÂ distribuito, ma ancheÂ affidabile, scalabile e sicuro (fault-tolerant by design).Â 
- Reti criticheÂ (es. reti 5G, industriali):Â RichiedonoÂ prestazioni estremeÂ (latenza bassissima, sicurezza altissima, ecc.).