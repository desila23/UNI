Riprendiamo la dimostrazione di ieri con le produzioni.
![[Pasted image 20250402193758.png]]

Dobbiamo dimostrare che $$L(G) = \{xx : x \in \{a,b\}^{+}\}$$ossia che ***con un dato insieme di parole e una propriet√† posso generare SOLO un linguaggio***.
##### Inizio dimostrazione
NON POSSIAMO ASSOLUTAMENTE INIZIARE CON LA PRODUZIONE $S \rightarrow X$ altrimenti 
- non potremmo mai generare alcuna parola in $\{a,b\}^{+}$
- non potremmo mai togliere il non terminale X
- non potremmo pi√π aggiungere caratteri a o b a sinistra di X

Per√≤ possiamo avere tutta una serie di produzioni e mettere X alla fine
	![[Pasted image 20250403175732.png|center]]
	Una volta che sono arrivato ad avere la X alla fine NON POSSO PI√ô METTERE $a$ o $b$ PRIMA di X e quindi avr√≤ $n$ terminali prima di X (oltre a $n$ NON TERMINALI $U$.

Possiamo ora applicare le produzioni
- $U_{0}X \rightarrow X0$
- $U_{1}X \rightarrow X1$
per rimuovere tutti i non terminali $U_{i}$ 

Oppure, se subito a sinistra della $X$ non abbiamo una $U_{i}$ possiamo applicare le produzioni
- $U_{0}0 \rightarrow 0U_{0}$
- $U_{1}1 \rightarrow 1U_{1}$
- $U_{0}1 \rightarrow 1U_{0}$
- $U_{1}0 \rightarrow 0U_{1}$
per poter applicare le produzioni scritte prima (posso farle sia una alla volta che tutte insieme, cio√® mettere TUTTE le $U$ vicine) $$x_{1}, x_{2}, x_{3},...,U_{1}, U_{2}, U_{3}, X0$$

Inizio quindi a togliere i non terminali swappandoli con la X (produzioni scritte sopra) FINO AL PENULTIMO.
Sull'ultimo devo utilizzare una tra le due produzioni
- $U_{0}X \rightarrow 0$
- $U_{1}X \rightarrow 1$


## Grammatiche e macchine di Turing
Due definizioni importanti
###### GRAMMATICA
La grammatica √® un modello di calcolo e descrivere come si possono generare le parole appartenenti a un insieme di parole
###### MACCHINA DI TURING
La Macchina di Turing √® un modello di calcolo e una macchina di Turing descrive come si fa a riconoscere le parole appartenenti a un insieme di parole.

>[!danger] Vogliamo dimostrare che i due modelli di calcolo sono equivalenti
>Ossia che
>- se un linguaggio √® accettato da una macchina di Turing allora esiste una grammatica (di tipo 0) che lo genera
>- se un linguaggio √® generato da una grammatica (di tipo 0) allora esiste una macchina di Turing che lo accetta.
>
NB: Il tipo non √® troppo importante, ma se proprio devo sceglierlo la scelgo di tipo 0 dato che ho meno vincoli.


>[!tip] Teorema tecnico (che ci servir√† per la dimostrazione)
$\forall$ macchina $T$ (RICONOSCITORE) ad un nastro e con alfabeto $\{0,1\}$ 
>- esiste una macchina $T'$ con un solo nastro semi-infinito (ha una prima cella iniziale e infinite celle finali) e che non scrive mai $\square$ (in modo da simulare il comportamento delle grammatiche) tale che 
>	- $\forall \ x \in \{0,1\}^{*},\ [o_{T}(x) = o_{T'}(x)]$


>[!lemma] Teorema G4
>$\forall$ linguaggio accettabile $L$ esiste una grammatica G (di tipo 0) tale che $$L = L(G)$$

#### Dim. spg (senza perdere generalit√†)
###### macchina di Turing
Sia $T$ la macchina di Turing che accetta $L$, definita come $$T = ( \{0,1\}, \ Q, \ P_{T}, \ q_{0}, \ \{q_A, q_R\} )$$Dove:
- $\{0,1\}$ √® l‚Äôalfabeto
- $Q$ √® l‚Äôinsieme degli **stati**
- $P_{T}$ √® il programma (insieme delle transizioni)
- $q_{0}$ √® lo stato iniziale
- ${q_A, q_R}$ sono gli stati finali (accetta/rifiuta)

‚û° E assumiamo che:
- T abbia **un solo nastro**
- Il nastro sia **semi-infinito** (va solo a destra)
- T **non scriva mai il blank**

###### Grammatica
Definiamo una grammatica $$G = (V_{T}, \ V_{N}, \ P_{G}, \ S)$$dove:
- $V_{T}‚Äã=\{0,1,a,\square \}$ = simboli terminali
- $V_N = \{ S, A, C, D, X, U_0, U_1 \} \cup \{ q_i \} \cup \{ q_A, q_R \}$ = simboli non terminali
    - $S$ √® l‚Äôassioma
    - $q_{i}$ sono gli stati della macchina Turing
    - $U_0$, $U_1$ rappresentano 0 e 1 sotto forma "codificata"
    - $a, \square$ servono per "segnare" o "gestire" parti della configurazione del nastro
	
- $P_{G}$ = insieme delle produzioni (verr√† descritto dopo)

>[!idea] Idea per la dimostrazione
>Simuliamo il comportamento di $T$ con la grammatica $G$.

Avviene in 3 fasi:
1) Costruiamo una cosa del tipo $$a \ Q_{0} \ x$$dove 
	- $x \in \{0,1\}^{*}$ √® l'input
	- $q_{0}$ √® lo stato iniziale
	- $a$ √® un marcatore (vedremo poi per cosa lo utilizziamo)

2)  Viene simulata la computazione di $T$ su $x$
	- la grammatica applicher√† le **produzioni** che simulano le **transizioni** di $T$
		- ogni produzione descriver√† un passo della macchina: lettura, scrittura, movimento, cambio stato

3) Se la simulazione termina in $q_{A}$ la grammatica far√† sparire TUTTO CI√í CHE NON √à $x$ e quindi lascer√† solo $x$ sul nastro (perch√© √® l'unica cosa che ci interessa).

### FASE 1
>[!example] üéØ Obiettivo di questa fase
>**Costruire la configurazione iniziale della macchina di Turing** nella forma: $$x \ a \ Q_{0} \ x \ \square$$dove:
>- i primi simboli li abbiamo visti gi√† prima
>- il secondo $x$ √® la copia dell'input
>- $\square$ √® il simbolo blank che serve esclusivamente per indicare la fine della parola scritta sul nastro

Abbiamo bisogno delle produzioni che possano generare questa stringa.
Guarda caso sono identiche a quelle della scorsa lezione
![[Pasted image 20250403194018.png||center]]


### FASE 2
Dopo la fase 1 abbiamo costruito la configurazione iniziale $$x \ a \ Q_{0} \ x \ \square$$Ora, nella fase 2, la grammatica $G$ deve simulare **ogni transizione della macchina di Turing**. 
Cio√®, deve "imitare" $T$ attraverso delle **produzioni grammaticali**
###### Rappresentazione delle transizioni
Possiamo avere due transizioni principali
- $<q_{i1}, \ h_{1}, \ h_{2}, \ q_{i2}, \ sx>$
- $<q_{i1}, \ h_{1}, \ h_{2}, \ q_{i2}, \ dx>$

Significa:
> "Se sono nello stato `q·µ¢‚ÇÅ` e leggo `h‚ÇÅ`, allora scrivo `h‚ÇÇ`, passo allo stato `q·µ¢‚ÇÇ` e mi muovo **a sinistra** o **a destra**".

Nel pratico io dovr√≤ modificare quello che trovo dopo `a` nella parola generata nella fase 1, andando a "imitare" $T$.
L'obiettivo √® raggiungere $q_{a}$.

Un esempio visivo che ti sar√† chiaro dopo
```css
011 a Q‚ÇÄ 011 ‚ñØ
‚ü∂ 011 a 0 Q‚ÇÅ 11 ‚ñØ
‚ü∂ 011 a 0 1 Q‚ÇÇ 1 ‚ñØ
‚ü∂ 011 a 0 1 1 Q_A ‚ñØ
```
Se vedi ho modificato solo quello che leggo dopo `a`.


>[!question] Per√≤ come faccio a riportare l'effettiva operazione di "scrittura e spostamento" in una grammatica? 

Lo fa utilizzando produzioni del tipo 
	`b q·µ¢‚ÇÅ h‚ÇÅ ‚Üí q·µ¢‚ÇÇ b h‚ÇÇ`
	(per la mossa a sinistra)
Oppure
	`q·µ¢‚ÇÅ h‚ÇÅ b ‚Üí q·µ¢‚ÇÇ h‚ÇÇ b`
	(per la mossa a destra)

>[!tip]- Spiegazione delle transizioni (guarderemo quella a `sx` ma vale anche per `dx`)
>Quello che leggi prima di `‚Üí` indica la struttura del nastro PRIMA DI ESEGUIRE LA QUIINTUPLA, dove
>- `b` √® un simbolo a caso
>- `q·µ¢‚ÇÅ` √® lo stato attuale **prima della transizione**, e indica dove si trova la testina (che √® **posizionata su** `h‚ÇÅ`)
>- `h‚ÇÅ` √® il simbolo da dover leggere
>
>Ora, dopo aver eseguito una data quintupla la situazione sar√† uguale a quello che leggi dopo `‚Üí`, ossia 
>- `h‚ÇÇ` √® quello che ho scritto al posto di `h‚ÇÅ`
>- `b` √® sempre il simbolo a caso che prima NON ABBIAMO MODIFICATO
>- `q·µ¢‚ÇÇ` √® lo stato in cui siamo entrati e sempre la testina (CHE SI TROVA A SINISTRA DI `b` PERCH√â CI SIAMO SPOSTATI A `SX`.
>
>Quindi ora dovremmo eseguire qualche operazione trovandoci nello stato `q·µ¢‚ÇÇ` e leggendo `b`.

##### Definizione della mossa a sinistra
Per ogni quintupla `<q·µ¢‚ÇÅ, h‚ÇÅ, h‚ÇÇ, q·µ¢‚ÇÇ, sx>` in $P_{T}$
	$P_{G}$ contiene le produzioni `b Q·µ¢‚ÇÅ h‚ÇÅ ‚Üí Q·µ¢‚ÇÇ b h‚ÇÇ`

>[!question] E se avessimo una quintupla del tipo `<q·µ¢‚ÇÅ, ‚óª, h‚ÇÇ, q·µ¢‚ÇÇ, sx>`?
>Ossia, se leggessimo $\square$ (quindi ci troviamo DOPO l'ultimo carattere a destra) e provassimo a scrivere qualcosa, come dovremmo comportarci?
>Andiamo a scrivere `h‚ÇÇ` sul blank, aggiungiamo un nuovo blank (a destra) e spostiamo la testina a sinistra.
>
>Detto in termini grammaticali avremo una produzione del tipo `b Q·µ¢‚ÇÅ h‚ÇÅ ‚Üí Q·µ¢‚ÇÇ b h‚ÇÇ ‚óª`

##### Definizione della mossa "fermo"
Per ogni quintupla `<q·µ¢‚ÇÅ, h‚ÇÅ, h‚ÇÇ, q·µ¢‚ÇÇ, f>` in $P_{T}$
	$P_{G}$ contiene le produzioni `Q·µ¢‚ÇÅ h‚ÇÅ ‚Üí Q·µ¢‚ÇÇ h‚ÇÇ`

>[!question] E se avessimo una quintupla del tipo `<q·µ¢‚ÇÅ, ‚óª, h‚ÇÇ, q·µ¢‚ÇÇ, f>`?
>Avremo una produzione del tipo `Q·µ¢‚ÇÅ h‚ÇÅ ‚Üí Q·µ¢‚ÇÇ h‚ÇÇ ‚óª`
>Dove `h‚ÇÅ = ‚óª`

##### Definizione della mossa a destra
Per ogni quintupla `<q·µ¢‚ÇÅ, h‚ÇÅ, h‚ÇÇ, q·µ¢‚ÇÇ, ds>` in $P_{T}$
	$P_{G}$ contiene le produzioni `Q·µ¢‚ÇÅ h‚ÇÅ ‚Üí h‚ÇÇ Q·µ¢‚ÇÇ`

>[!question] E se avessimo una quintupla del tipo `<q·µ¢‚ÇÅ, ‚óª, h‚ÇÇ, q·µ¢‚ÇÇ, dx>`?
>Avremo una produzione del tipo `Q·µ¢‚ÇÅ h‚ÇÅ ‚Üí h‚ÇÇ Q·µ¢‚ÇÇ ‚óª`


#### Alcune osservazioni importati
1) Le produzioni della fase 2 **possono essere applicate solo a parole che contengono `Q‚ÇÄ`**  
	(cio√®: solo dopo che `X` √® stato rimosso dalla parola iniziale generata nella fase 1)
	Se noti, guarda le varie produzioni
	![[Pasted image 20250403220232.png|center]]CON LA VERDE genero `X`
	CON LA ROSSA rimuovo `X` e ho `Q‚ÇÄ`


2) Ogni parola generata durante la fase 2 contiene **uno e un solo simbolo `q·µ¢`**, cio√® **uno stato**
	Anche perch√© `q·µ¢` rappresenta la testina e il nastro √® unico -> quindi ho una sola testina


3) La porzione di parola **a destra del simbolo `a`** rappresenta **gli stati globali della computazione**  Quindi una parola viene generata **solo se** contiene un non terminale `q_A` (stato di accettazione)
	Nel senso che, io ho la parola `x a Q‚ÇÄ x ‚óª` dove
	- il primo `x` √® l'input
	- `a` √® un separatore
	- `Q‚ÇÄ x ‚óª` rappresenta lo stato globale della macchina di Turing.
	 
	Se, in un dato momento, la parola diventa `x a q‚Çê` allora vorr√† dire che originariamente $T(x) = q_{a}$ e quindi **una parola √® effettivamente generata dalla grammatica G**


4) Se la computazione T(x) **non termina nello stato di accettazione** `q‚Çê`,  allora **qualsiasi parola generata durante la fase 2** contiene **un non terminale**  appartenente all‚Äôinsieme `{q·µ¢ : i = 0, ..., k} ‚à™ {q·µ£}`.
	In pratica, se non termino in `q‚Çê` avr√≤ sempre un carattere non terminale che pu√≤ essere
	- uno stato attuale `q·µ¢ : i = 0, ..., k`
	- lo stato di rigetto `q·µ£`
	
	### üîê OSS4 √® una "protezione":
	Impedisce che vengano generate parole terminali se la simulazione **non √® andata a buon fine**.


5) Qualunque parola generata durante la fase 2 ha **come ultimo carattere** il **blank** `‚ñØ`
	Questo perch√© ogni volta che **la testina si sposta a destra**, la grammatica **aggiunge un nuovo `‚ñØ` alla fine**.
	
	### ‚úÖ Perch√© √® utile?
	1. Serve per **delimitare la fine del nastro** simulato
	2. Permette alle produzioni della grammatica di sapere dove si trova il **bordo destro**, utile nelle riscritture
	3. Aiuta a identificare che la simulazione √® ancora **in corso** o **pronta a terminare**



### FASE 3
Ora tocca alla fase di "pulizia", ossia 
- SE E SOLO SE $T(x)$ ha terminato in `q‚Çê` (e quindi se leggiamo `q‚Çê` nella parola costruita nella FASE 1 e modificata nella FASE 2)
	- possiamo eliminare tutti i caratteri dopo `a` 
	- lasciare solo l'input `x`

Per farlo abbiamo bisogno di alcune produzioni
1. Per ogni `b ‚àà {0,1}`:
	`q‚Çê b ‚Üí b q‚Çê`
		fa slittare `q‚Çê` a destra dei vari simboli (vogliamo portarla a **sinistra del blank**)

2. Poi:
	`q‚Çê ‚ñØ ‚Üí C`
		trasformo la coppia `q‚Çê ‚ñØ` in un carattere speciale `C`

3. Poi:
	`b C ‚Üí C     (per ogni b ‚àà {0,1})`
		`C` avr√† prima di s√© tanti caratteri (‚àà {0,1}) che verranno mano mano "eliminati"

4. Infine:
	`a C ‚Üí Œµ`
		Dopo aver eliminato tutti i caratteri rimane solo `a` con `C`, che trasformo in una **parola vuota** (`Œµ`) e quindi le **cancello definitivamente**
###### ESEMPIO GRAFICO
![[Pasted image 20250403223536.png]]

#### Altre osservazioni
6) Le produzioni della fase 3 possono essere applicate **solo se** nella parola c‚Äô√® `q‚Çê`.
	anche perch√© se noti le prime due produzioni posso eseguirle SOLO SE ho `q‚Çê`

7) Se applichi le produzioni della fase 3 a una parola che contiene solo `q‚Çê` come non terminale e termina con `‚ñØ`,  allora ottieni una parola **composta solo dai simboli a sinistra di `a`**, cio√® proprio l‚Äôinput `x`.

#### Mega conclusione (e sintesi)
![[Pasted image 20250403225849.png]]
![[Pasted image 20250403225908.png]]