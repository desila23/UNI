Due tipi di collegamento:Â 
1. ***Punto a punto***,Â un mittente e un ricevente ;Â 
2. ***Broadcast*** (cavo o mezzo condiviso), piÃ¹ nodi e ciascun frame viene ricevuto da tutti i nodi
	ad esempio, nella rete wireless dove tutti i dispositivi connessi "sentono" i dati e poi ognuno decide se quel messaggio Ã¨ per lui.Â 


Quando piÃ¹ dispositivi usano lo stessoÂ **canale** (mezzo)Â per trasmettere dati puÃ² succedere che parlino insieme e si sovrappongano o che un nodo riceva due o piÃ¹ segnali nello stesso istanteÂ (***collisione***).Â 
La soluzione Ã¨ usare un protocollo che regoli il tutto:Â 
- Determina come i nodi condividono il canaleÂ 
- Chi puÃ² trasmettereÂ 
- Gestisce la comunicazione sul canale stessoÂ 
Questo Ã¨ ilÂ **protocollo di accesso multiplo**.Â 

IdealmenteÂ se abbiamo un unico canale usato da piÃ¹ dispositivi (*multiple access channel, MAC*)Â per trasmettere dati vorremmo che:Â 
1. Se solo un nodo trasmettere -> puÃ² utilizzare tutta la velocitÃ  RÂ 
2. Quando M nodi vogliono trasmettere -> ognuno deve avere $\frac R M$ velocitÃ Â 
3. Non ci sono nodi speciali che coordinano il tutto (tipo un nodo "capo") 
	perchÃ© se quel nodo si guasta, bloccheremmo tutto.
	Si diceÂ ***decentralizzato***, perchÃ©Â ognuno si autogestisceÂ 
4. Un meccanismo sempliceÂ 


---

### Tassonomia (classificazione) dei PAMÂ 
##### 1. A suddivisione del canaleÂ Â 
Il canale viene diviso in "pezzi" piÃ¹ piccoli (frequenze, codici, slot temporali) 
- ogni nodo **ottiene un suo turno fisso** per trasmettere.

##### 2. Accesso casuale (random access)Â 
Il canaleÂ non Ã¨ diviso,Â i nodi possono trasmettere quando vogliono con rischio di collisioni, che vengono recuperate con la ritrasmissioneÂ 

##### 3. A rotazione (turni)Â 
I nodi trasmettono a turno, piÃ¹ dati = piÃ¹ turnoÂ 


---

## â±ï¸Protocolli a suddivisione del canale: TDMA (Time Division Multiple Access)Â 
##### ğŸ” Come funziona
1. **Il tempo Ã¨ diviso in "frame temporali"**
	- Ogni frame temporale Ã¨ una **sequenza regolare e ciclica**.
	
 2. Ogni frame Ã¨ suddiviso in **N slot temporali**
	- **N** = numero di nodi (es: 6 dispositivi â†’ 6 slot per frame).
	- Ogni slot Ã¨ assegnato a **un nodo fisso**.
	
3. In ogni slot, **solo il nodo a cui Ã¨ assegnato puÃ² trasmettere**
	- Nessun conflitto, nessuna collisione.

##### ğŸ¯ Obiettivo
- **Eliminare le collisioni** (nessuno trasmette fuori dal proprio turno).
- Garantire a ciascun nodo **un accesso regolare** e **prevedibile** al canale.

##### âŒ Problematiche
- Gli slot inutilizzati rimangono inutilizzati (idle)
- richiede molta sincronizzazione dei nodi

##### ğŸ§ª Esempio
![[Pasted image 20250512154230.png]]
- Ho 6 nodi
- 1, 3, 4 hanno pacchetti da inviare -> usano i loro slot
- 2, 5, 6 non hanno pacchetti da inviare -> i loro slot rimangono inutilizzati (spreco)

>[!tip] Il motivo per cui Ã¨ inefficiente
>- Un nodo che ha dati da trasmettere SEMPRE deve attendere il proprio turno.
>- Un nodo trasmette a `R` bps,  ma lo puÃ² fare solo in $\frac 1 N$ della durata dell'intervallo temporale; quindi la sua velocitÃ  media Ã¨ $\frac R N$, A PRESCINDERE DAL FATTO CHE CI SIANO ALTRI NODI CHE VOGLIANO TRASMETTERE SUL CANALE.



## ğŸ“¶ Protocolli a suddivisione del canale: FDMA (frequency division multiple access)
##### ğŸ” Come funziona
In FDMA, **il canale viene diviso in bande di frequenza fisse**.
- Ogni nodo ha **una sua banda dedicata** (es. 1Â° nodo â†’ banda blu, 2Â° nodo â†’ rossa, ecc.).
- I nodi possono trasmettere **in qualsiasi momento**, ma **solo nella propria banda**.
- Il **tempo non Ã¨ suddiviso**: ogni nodo puÃ² trasmettere anche per unâ€™ora intera, se serve, purchÃ© stia nella sua banda.

ğŸ“¡ Quindi in questo caso ogni nodo puÃ² trasmettere ***QUANDO*** gli pare, ma con la limitazione della larghezza di banda assegnata.

##### ğŸ¯ Obiettivo
- Consentire **trasmissioni simultanee** da parte di piÃ¹ nodi **senza collisioni**.
- Garantire a ciascun nodo **un canale indipendente**, sempre disponibile.
- Evitare la necessitÃ  di **coordinazione temporale** (a differenza del TDMA).

##### âŒ Problematiche
- Se un nodo **non ha dati da inviare**, la **sua banda resta sprecata** (idle).
- Ogni nodo ha **una banda fissa** â†’ se ha molto da trasmettere, **non puÃ² usare le altre bande** anche se sono libere.

##### ğŸ§ª Esempio
![[Pasted image 20250512163614.png]]
- Supponiamo una **LAN con 6 nodi**.
- I nodi **1, 3 e 4** hanno pacchetti da inviare â†’ stanno trasmettendo nelle loro bande.
- I nodi **2, 5 e 6** non stanno trasmettendo â†’ le **loro bande restano inutilizzate**.

ğŸ“‰ Il sistema funziona, ma **la capacitÃ  complessiva non Ã¨ sfruttata al 100%**.

>[!tip] Nota come anche in questo caso la velocitÃ  Ã¨ $\frac N R$, a prescindere che altri vogliano trasmettere


>[!question]- Come Ã¨ possibile che in entrambi i casi sia $\frac R N$
>###### TDMA
>- ho `N` nodi
>- ognuno ha un suo frame temporale
>- anche se un nodo invia tanti pacchetti, DURANTE UN GIRO COMPLETO, lui avrÃ  inviato SOLO nel suo frame temporale, quindi avrÃ  usato $R \cdot \frac 1 N$ velocitÃ  totale
>
>###### FDMA
>Qui Ã¨ ancora piÃ¹ evidente
>- ho `N` pacchetti
>- ognuno puÃ² trasmettere sempre ma ha una banda limitata, $\frac 1 N$ del totale
>- quindi anche qui viene trasmesso a $\frac R N$ 


### Protocolli ad accesso casuale
Quando un nodo ha un pacchetto da inviare **lo trasmette subito (poi vedremo bene cosa significa "subito") alla massima velocitÃ **.
Se due o piÃ¹ nodi trasmettono nello stesso istante c'Ã¨ **collisione**.Â 

Un protocollo ad accesso casualeÂ deve specificare **come rilevare le collisioni**Â eÂ **cosa fare in caso di collisione** (di solito viene ritrasmesso il pacchetto).


#### Slotted ALOHA
##### ğŸ” Come funziona
Slotted ALOHA Ã¨ un protocollo in cui:
- **Il tempo Ã¨ diviso in slot regolari** (tutti i nodi condividono la stessa divisione temporale).
- Quando un nodo ha un frame da inviare, **puÃ² farlo solo all'inizio del prossimo slot**.
- Se due o piÃ¹ nodi trasmettono nello stesso slot, **si verifica una collisione**: entrambi i pacchetti sono persi.
- Se **non câ€™Ã¨ collisione**, il pacchetto arriva correttamente.

Dopo una collisione, i nodi **non ritrasmettono subito**, ma **con una certa probabilitÃ  p**, in uno degli slot successivi (scelta casuale â†’ "accesso casuale").

##### ğŸ§ª Esempio
![[Pasted image 20250512165012.png]]
- <font color="#ff0000">C</font> = CollisioneÂ (due nodi trasmettono nello stesso slot)Â 
- <font color="#00b050">R</font> = RiuscitoÂ (solo un nodo trasmette â†’ ok)Â 
- <font color="#00b0f0">I</font> = InutilizzatoÂ (nessuno trasmette)Â 

Cosa succede:Â 
- **Slot 1**:Â 
	Nodo 1, Nodo 2 e Nodo 3 trasmettonoÂ insiemeÂ â†’Â collisione (<font color="#ff0000">C</font>)Â 
- **Slot 2**:Â 
	Nessun nodo trasmette â†’Â slot inutilizzato (<font color="#00b0f0">I</font>)Â Â 
- **Slot 3**:Â 
	Nodo 1 e Nodo 2 trasmettonoÂ insiemeÂ â†’Â collisione (<font color="#ff0000">C</font>)Â 
- **Slot 4**:Â 
	Solo il nodo 2 trasmette â†’Â trasmissione riuscita (<font color="#00b050">R</font>)Â 
- **Slot 5**:Â 
	Nessun nodo trasmette â†’Â slot inutilizzato (<font color="#00b0f0">I</font>)Â 
- **Slot 6**:Â 
	Nodo 1 e Nodo 3 trasmettonoÂ insiemeÂ â†’Â collisione (<font color="#ff0000">C</font>)Â 
- **Slot 7**:Â 
	Nessun nodo trasmette â†’Â slot inutilizzato (<font color="#00b0f0">I</font>)Â 
- **Slot 8**:
	Solo il nodo 1 trasmette â†’Â trasmissione riuscita (<font color="#00b050">R</font>)Â 
- **Slot 9**:
	Solo il nodo 3 trasmette â†’Â trasmissione riuscita (<font color="#00b050">R</font>)Â 

| <center>âœ… **Pro**</center>                                                          | <center>âŒ **Contro**</center>                                                           |
| ----------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| Un singolo nodo attivo puÃ² trasmettere **alla massima velocitÃ  del canale**         | **Collisioni** frequenti, specialmente con molti nodi attivi                            |
| Ãˆ **altamente decentralizzato** (basta sincronizzare gli slot, non i nodi tra loro) | **Spreco di slot** (a causa della natura probabilistica del protocollo)                 |
| Ãˆ **semplice da implementare**                                                      | **Slot inutilizzati** anche se ci sono pacchetti da inviare                             |
| <font color="#00b0f0">palle</font>                                                  | I nodi **potrebbero rilevare collisioni prima del termine dello slot**, sprecando tempo |
| <font color="#92d050">culo</font>                                                   | Richiede **sincronizzazione degli orologi** tra i nodi                                  |

#### Slotted ALOHA: efficienza
![[GetImage - 2025-05-12T170542.879 1.png]]
![[GetImage - 2025-05-12T170605.595.png]]


![[GetImage - 2025-05-12T170635.142.png]]
![[GetImage - 2025-05-12T170647.075.png]]
![[GetImage - 2025-05-12T170707.737.png]]


### ALOHA puro - Unslotted ALOHA
##### ğŸ” Come funziona
- In ALOHA puro **non c'Ã¨ alcuna sincronizzazione** tra i nodi.
- Quando un nodo ha un pacchetto da inviare, **lo trasmette subito**, **senza aspettare uno slot**.
	- Se la trasmissione **va a buon fine**, ok.
	- Se **collide con altri frame**, il nodo **aspetta un tempo casuale** e poi **ritrasmette con probabilitÃ  `p`**.


##### âŒ Problematiche
![[Pasted image 20250512171342.png]]
- **Alta probabilitÃ  di collisione**, molto piÃ¹ che in Slotted ALOHA.
- <font color="#ff0000">PerchÃ©?</font> PerchÃ© in ALOHA puro un frame puÃ² **iniziare in qualsiasi momento**, quindi:
    - puÃ² **sovrapporsi all'inizio o alla fine di un altro frame** (come mostrato nell'immagine).
    
- Un frame inviato in `tâ‚€` puÃ² essere **distrutto** da qualsiasi altro frame che arriva in 
	`[tâ‚€ - T, tâ‚€ + T]`, dove `T` Ã¨ la durata di un frame.
    
- Questo **raddoppia la "zona di vulnerabilitÃ "** rispetto a Slotted ALOHA.

ğŸ“‰ Risultato: **solo il 18% del tempo di canale** viene effettivamente usato per trasmissioni riuscite.



### ğŸ“¡ Accesso multiplo con rilevamento della portante (*carrier sense multiple access*, CSMA)
#### CSMA
ğŸ§  Idea base:
> "Ascolta il canale prima di trasmettere"

Invece di buttarsi a trasmettere come fanno i protocolli ALOHA, con CSMA **ogni nodo prima ascolta** il canale per vedere se qualcun altro sta giÃ  trasmettendo.
- **Se il canale Ã¨ libero** â†’ il nodo trasmette.
- **Se Ã¨ occupato** â†’ il nodo **aspetta** e ritenta dopo.

Questo comportamento evita molte collisioni inutili, ed Ã¨ **piÃ¹ intelligente** rispetto ad ALOHA, che trasmette alla cieca.

#### CSMA/CD (Collision detection)
ğŸ§  Estensione di CSMA:
> "Ascolta prima di parlare... e se qualcuno parla mentre parli anche tu, smetti subito!"

CSMA/CD migliora CSMA aggiungendo la **capacitÃ  di rilevare collisioni**:
- Il nodo **continua ad ascoltare mentre trasmette**.
- Se rileva che un altro nodo ha iniziato a trasmettere contemporaneamente, **capisce che câ€™Ã¨ stata una collisione**.
- A quel punto:
    - **interrompe subito** la trasmissione (non spreca tempo).
    - **aspetta un tempo casuale** (backoff).
    - Riprova piÃ¹ tardi.

>[!bug] Questo rilevamento delle collisioni funziona molto bene in Ethernet cablata, ma Ã¨ piÃ¹ complicata wireless

### ATTENZIONE: le collisioni sono ancora possibili con CSMA
Il motivo principale Ã¨ il **ritardo di propagazione**.

Infatti, quando un nodo inizia a trasmettere, il segnale ci mette un poâ€™ di tempo per viaggiare nel mezzo fisico (es. cavo o aria) e raggiungere gli altri nodi.

###### ğŸ“‰ Esempio per capire
Immagina 2 nodi distanti:
1. Nodo A ascolta â†’ canale libero â†’ **inizia a trasmettere** a tempo `tâ‚€`.
2. Nodo B Ã¨ lontano â†’ **non ha ancora ricevuto il segnale di A**.
3. Nodo B ascolta â†’ sente il canale **ancora libero** â†’ **anche lui inizia a trasmettere**.
4. I due segnali **si sovrappongono durante la propagazione** â†’ **collisione**.

Anche se entrambi hanno â€œascoltato prima di parlareâ€, **non avevano ancora ricevuto lâ€™informazione che il canale era occupato**, quindi trasmettono comunque â†’ collisione inevitabile.

###### âŒ Effetto della collisione
- La **collisione rovina l'intero pacchetto**.
- Si **spreca tutto il tempo di trasmissione**, perchÃ© il pacchetto va **completamente perso**.
- Inoltre, i nodi devono poi **ritrasmettere**, introducendo **ritardi** e **sovraccarico**.

###### ğŸ“ Fattori che aumentano le collisioni
- **Maggiore distanza tra i nodi**.
- **Segnali piÃ¹ lunghi** (pacchetti lunghi â†’ piÃ¹ tempo esposti a collisioni).
- **VelocitÃ  di propagazione limitata**.

#### La cosa viene in parte risolta con CSMA/CD
ğŸ”§ **CSMA/CD aggiunge una funzione chiave**:
> Se un nodo **inizia a trasmettere** e **sente che câ€™Ã¨ una collisione**, **interrompe subito** la trasmissione.

In questo modo viene ridotto il tempo sprecato nelle collisioni, perchÃ©:
- Senza CSMA/CD:
	- Il nodo trasmette **lâ€™intero frame anche se câ€™Ã¨ stata una collisione** â†’ **tempo completamente perso**.

- Con CSMA/CD:
	- Il nodo si accorge **durante la trasmissione** che câ€™Ã¨ un problema e **si ferma subito** â†’ **spreca solo una piccola parte**.



##### âš™ï¸ Algoritmo CSMA/CD in Ethernet â€“ spiegazione passo-passo
1. Ricezione del pacchetto
	Ethernet riceve un datagramma IP dal livello 3 (livello di rete) e lo impacchetta in un frame Ethernet (livello 2).

 2. Ascolto del canale
	Ethernet ascolta il canale prima di trasmettere:
	- **Canale libero** â†’ inizia subito la trasmissione.
	- **Canale occupato** â†’ aspetta finchÃ© si libera, poi trasmette.

3. Se la trasmissione va a buon fine
	- Nessuna collisione â†’ il frame Ã¨ stato trasmesso correttamente â†’ **finito âœ…**
	ğŸ¯ Questo Ã¨ il caso ideale.

 4. Se viene rilevata una collisione
	Durante lâ€™invio:
	- Se il nodo rileva che un altro sta trasmettendo nello stesso momento (il segnale si distorce),
	- Allora **interrompe subito** la trasmissione
	- E manda un **segnale speciale chiamato jam**: un messaggio che **avvisa tutti** della collisione.
	ğŸ’¥ Questo riduce lo **spreco di tempo**: tutti smettono di trasmettere appena capiscono che c'Ã¨ stata una collisione.

5. Backoff esponenziale binario (binary exponential backoff)
	Dopo la collisione, il nodo **non ritenta subito**: entra in modalitÃ  di attesa casuale.
	
	ğŸ“‰ Come funziona?
	- Supponiamo che questa sia la **m-esima collisione**.
	- Il nodo sceglie **un numero casuale `K`** tra `0` e `2^m âˆ’ 1`.
	- Aspetta per un tempo pari a **K slot**, dove ogni slot = **tempo di trasmissione di 512 bit**.
	- Poi ritorna al punto 2 â†’ ascolta di nuovo, e ritenta a trasmettere.
	
	â±ï¸ PiÃ¹ collisioni â†’ **intervallo di attesa piÃ¹ ampio** â†’ riduce la probabilitÃ  che i nodi ritrasmettano ancora insieme.
	
	ğŸ§· Ma: `m` Ã¨ **limitato a 10** (Ã¨ uno standard ufficiale) â†’ lâ€™intervallo massimo di backoff non cresce allâ€™infinito. 

##### Efficienza CSMA/CD
![[Pasted image 20250512174715.png]]

---

## Protocolli a rotazione
Innanzitutto, un piccolo recap dei due protocolli precedenti
![[Pasted image 20250512175128.png]]

Ora, i protocolli a rotazione cercano di prendere il meglio di entrambi, ossia vogliono essere 
- **efficienti come CSMA** a basso traffico,
- **ordinati ed equi come TDMA** ad alto traffico.

Sono chiamati **â€œa rotazioneâ€** perchÃ© spesso i nodi **si alternano nel diritto di trasmettere**, ma in modo piÃ¹ **dinamico** rispetto a TDMA.


### Protocolli a rotazione: Polling
ğŸ§  Idea di base
> Un **controllore centrale** (master) gestisce l'accesso al canale.  
> I nodi **non trasmettono autonomamente**, ma **aspettano di essere invitati**.

![[Pasted image 20250512175747.png|center|500]]
##### ğŸ”¹ Come funziona
1. Il **controllore invia un segnale di "poll"** a un nodo client.
2. Il nodo riceve il permesso â†’ **puÃ² trasmettere i suoi dati**.
3. Quando ha finito (cioÃ¨ **non manda piÃ¹ segnali**), il controllore lo capisce.
4. Il **controllore passa al nodo successivo**, e cosÃ¬ via.

##### âš™ï¸ **Vantaggi**
- Nessuna collisione: ogni nodo parla solo quando autorizzato.
- **Accesso ordinato**, utile quando i dispositivi sono "deboli" o devono essere gestiti centralmente (es. cuffie Bluetooth, sensori...).

##### âŒ **Problemi del polling**
1. **Overhead del polling**
    - Il controllore deve **inviare continuamente segnali di polling**, anche se nessun nodo ha dati â†’ **spreco di banda**.
    
2. **Ritardo di polling**
    - Anche se **solo un nodo ha qualcosa da dire**, deve **aspettare il suo turno**.
    - Il master deve **chiedere a tutti**, uno per uno, prima di tornare a quel nodo â†’ **basso throughput** in situazioni di carico leggero.
    
3. **Punto singolo di guasto**
    - Se il **controllore centrale fallisce**, tutta la rete **si blocca**.
    - Nessun nodo puÃ² piÃ¹ comunicare autonomamente.

>[!tip] Il bluetooth usa il polling.


### Protocolli a rotazione: Token Passing
ğŸ§  Idea base
> Un **gettone virtuale (token)** gira tra i nodi della rete.  
> **Solo chi ha il token puÃ² trasmettere**.

![[Pasted image 20250512175831.png|center|300]]
##### ğŸ”¹ Meccanismo
- Câ€™Ã¨ un **token**, un piccolo messaggio di controllo che viene **passato da nodo a nodo**, in ordine.
- Quando un nodo **riceve il token**, puÃ²:
    - Trasmettere i suoi dati (se ne ha).
    - Se non ha nulla da inviare â†’ **passa subito il token al successivo**.
    
- Il token **circola continuamente** tra i nodi.

##### âœ… **Vantaggi**
- **Nessuna collisione**: solo uno alla volta puÃ² trasmettere.
- L'accesso al canale Ã¨ **ordinato e prevedibile**.
- **Equo**: tutti i nodi ricevono lo stesso diritto di trasmettere.

##### âŒ **Problemi**
1. **Overhead del token**
    - Il token stesso occupa banda.
    - Se ci sono pochi dati, si trasmette piÃ¹ il â€œgettoneâ€ che le informazioni effettive.
    
2. **Latenza**
    - Un nodo che vuole trasmettere deve **aspettare il proprio turno**, anche se il canale Ã¨ libero.
    
3. **Singolo punto di rottura: il token**
    - Se il token va â€œpersoâ€ o si corrompe â†’ la rete si blocca.
    - Serve un meccanismo per **rigenerarlo**, ma Ã¨ complesso.

>[!tip] Viene usato in
>- **Token Ring** (standard IEEE 802.5) 
>- **FDDI** (Fiber Distributed Data Interface), reti su fibra ottica


---

## Rete di accesso via cavo: FDM, TDM, allocazione centralizzata e accesso casuale
![[Pasted image 20250512180339.png]]
#### ğŸ  Contesto: rete via cavo (es. Internet da operatore via coax)
- Hai tanti utenti collegati tramite cavo (lo stesso cavo coassiale) a un **CMTS** (Cable Modem Termination System), che Ã¨ gestito dal provider (ISP).
- Il CMTS si trova in una **stazione di testa** (la centrale del provider).
- Il modem utente riceve o trasmette tramite questo cavo comune.

##### ğŸ”½ **Downstream (dalla rete verso casa tua)**
Tecnica: **FDM** â€“ Frequency Division Multiplexing
- Il provider trasmette **piÃ¹ flussi in parallelo**, ognuno su una frequenza diversa:
    - Internet
    - TV
    - Controllo
- Ãˆ un **broadcast**: un solo CMTS trasmette, e **tutti ricevono**.
- **Nessun problema di accesso multiplo**: non câ€™Ã¨ competizione â†’ **Ã¨ uno-a-molti**.

##### ğŸ”¼ **Upstream (da casa tua verso la rete)**
Tecnica: **accesso multiplo + TDM**
- Qui **piÃ¹ utenti devono inviare dati allo stesso CMTS** â†’ serve una tecnica per organizzare chi trasmette e quando.
- Ci sono **piÃ¹ canali disponibili (fino a 1 Gbps)**, ma **piÃ¹ utenti devono condividere quei canali**.

>[!question]- ğŸ” Come viene gestito lâ€™accesso?
>- **Accesso casuale (tipo CSMA)**: gli utenti provano a trasmettere quando hanno dati.
>    - Se **ci riescono**, bene.
>    - Se **ci sono collisioni**, si gestisce con ritrasmissione.
>- **TDM assegnato**: se il CMTS capisce che un utente ha bisogno di piÃ¹ banda, gli **riserva alcuni slot temporali** (time slots), cosÃ¬ puÃ² trasmettere in modo ordinato.
>
>ğŸ’¡ Quindi: si inizia con accesso casuale, poi puÃ² diventare piÃ¹ strutturato se serve â†’ **ibrido tra flessibilitÃ  e ordine.**

### DOCSIS (Data Over Cable Service Interface Specification)
Ãˆ lo **standard che regola la trasmissione dati su rete via cavo**, usato da operatori come Fastweb, Vodafone, ecc.

Ti spiega **come viene gestito il traffico dati su un singolo cavo** condiviso tra piÃ¹ utenti, in entrambe le direzioni (download e upload).
![[Pasted image 20250512181049.png]]
##### ğŸ”½ **Downstream (dal provider verso casa)**
Identico a prima
##### ğŸ”¼ **Upstream (da casa verso il provider)**
Il tempo nel canale upstream Ã¨ suddiviso in **tanti minislot** (piccoli intervalli temporali).
Abbiamo due tipi di minislot
1. **Minislot assegnati**:
    - Il CMTS **decide in anticipo** chi puÃ² usare quale slot.
    - Questo viene comunicato tramite un **MAP frame** inviato nel canale di downstream.
    - Ãˆ un meccanismo simile al **TDM (Time Division Multiplexing)**.

2. **Minislot contesi**:
    - Non assegnati a nessuno â†’ **tutti gli utenti possono provarci**.
    - Gli utenti inviano richieste **con accesso casuale**.
    - Se avviene una collisione, si usa il **binary backoff** (come in CSMA/CD).


---

## Riassuntazzo
![[Pasted image 20250512181229.png]]