### Alcune questioni irrisolte
1. Innanzitutto c'era la definizioni delle classi di complessit√† non deterministiche
	Qui si parla di accettabilit√† di un linguaggio e 
	- pur sapendo che, ogni volta che fissiamo la quantit√† massima di risorse (spazio o tempo) utilizzabile, un linguaggio accettabile √® anche decidibile
	- NON CONOSCIAMO quante risorse occorrono per rigettare le parole non appartenenti al linguaggio

2. Poi, sappiamo che tutto ci√≤ che pu√≤ essere deciso da una macchia non deterministica pu√≤ anche essere deciso da una macchina deterministica
	- MA, un linguaggio che appartiene a `NTIME[f(n)]` non sappiamo ancora a quale classe di complessit√† temporale deterministica collocarlo
		- n√© sappiamo dire che "se appartiene a `NTIME[f(n)]` allora appartiene anche in `DTIME[qualche altra funzione]`" 


---

## La prima questione aperta
##### üß† **Contesto**
- Hai un linguaggio $L \in \text{NTIME}$
	- Questo significa: esiste una macchina non deterministica che, **se una parola $x \in L$**, **la accetta** in tempo $O(f(|x|))$

‚úîÔ∏è **Per le parole nel linguaggio**, sappiamo che **esiste un ramo accettante veloce**.

##### ‚ùó Il problema
- **Per le parole $x \notin L$**:
    - Non c'√® nessun ramo che accetta,
    - Ma **non sappiamo quanto tempo serve per rigettare**, perch√© bisogna **esplorare tutti i rami** (o, almeno, assicurarsi che _nessuno_ accetti).

> In altre parole: sappiamo che la macchina rigetta, ma **non sappiamo quanto tempo ci mette per concludere che ‚Äúnessun ramo accetta‚Äù**.

#### Teorema che risolve la questione
>[!lemma] Teorema 6.16
>![[content/Zphoto/Pasted image 20250430172027.png]]

Questo teorema dice
- se `f` √® <font color="#f79646">time-constructible</font> e $L$ √® in $NTIME[f(n)]$, allora una modifica della macchina $NT$ **che accetta le parole `x` di L eseguendo $O(f(|x|))$ istruzioni** √® anche capace di rigettare le parole **non in $L$** eseguendo **O(f(|x|))** istruzioni;
- se `f` √® <font color="#245bdb">space-constructible</font> e $L$ √® in $NSPACE[f(n)]$, allora una modifica della macchina $NT$ **che accetta le parole `x` di L eseguendo $O(f(|x|))$ celle del nastro** √® anche capace di rigettare le parole **non in $L$** eseguendo $O(f(|x|))$ celle del nastro;

Per dimostrarlo, ci avvaliamo del teorema 6.2
![[content/Zphoto/Pasted image 20250430172518.png]]

#### üî® Dimostrazione (solo del tempo)
Sappiamo che $L \in NTIME[f(n)]$.
##### üß© 1. Partenza
Sia $NT$ la macchina che accetta L, tale che $$ntime(NT, x) \le c \cdot f(|x|)$$e, poich√© f √® <font color="#f79646">time-constructible</font>, allora anche $c \cdot f$ √® <font color="#f79646">time-constructible</font>: allora esiste una macchina $T_{f}$ di tipo trasduttore che, per ogni $n \in ‚Ñï$ , 
- $T_{f}(1^{n})$ termina
	- con il valore $c \cdot f(n)$ scritto sul nastro di output
	- dopo aver eseguito $O(c \cdot f(n))$ istruzioni

##### üß© 2. Costruzione di una nuova macchina $\text{NT}'$
Costruiamo una nuova macchina non deterministica $\text{NT}'$, a tre nastri, che decide L.
Per ogni $x \in \Sigma^{*}$
- **Scrive** $|x|$ in unario su un secondo nastro e invoca la macchina $T_f$‚Äã che calcola $c \cdot f(|x|)$, e lo scrive in unario su un terzo nastro.
    
- Poi invoca $\text{NT}(x)$ per **simulare tutte le computazioni non deterministiche**.
    
- Ogni volta che un ramo di $NT(x)$ esegue un passo, $\text{NT}'$ controlla che il contatore (terzo nastro) non sia esaurito.
    - Se c‚Äô√® ancora un ‚Äò1‚Äô, lo toglie e continua.
    - Se termina il tempo, rigetta.
    
- Alla fine accetta se $NT(x)$ accetta entro il limite, altrimenti rigetta.

##### üìå Perch√© funziona?
- Per $x \in L$, esiste un ramo accettante in $\leq c \cdot f(|x|)$ passi ‚Üí $\text{NT}'$ lo trover√† e accetter√†.
    
- Per $x \notin L$, 
	- ogni ramo rifiuta entro il tempo limite ‚Üí$\text{NT}'$ li esaminer√† e rigetter√†
	- oppure finir√† il tempo senza trovare un'accettazione ‚Üí rigetta.

Quindi le computazioni su $\text{NT}'$ TERMINANO SEMPRE e, per questi ultimi due punti, possiamo affermare che $\text{NT}'$ DECIDE $L$.

##### ‚è±Ô∏è **Quanto tempo usa NT‚Äô?**
- Per calcolare $f(‚à£x‚à£)$ (in unario): serve $O(f(‚à£x‚à£))$ tempo, perch√© $f$ √® <font color="#f79646">time-constructible</font>.
- Per simulare tutte le computazioni entro $c \cdot f(|x|)$ passi: $O(f(‚à£x‚à£))$

‚úÖ Totale: $O(f(‚à£x‚à£))$

>[!tip] Per questo possiamo concludere che $L$ √® decidibile, in tempo non deterministico $O(f(n))$


---

## Seconda questione aperta
#### üîç **Punto di partenza**
Le **uniche relazioni sicure** che conosciamo finora tra classi **deterministiche** e **non deterministiche** sono le seguenti:
```
DTIME[f(n)] ‚äÜ NTIME[f(n)]
DSPACE[f(n)] ‚äÜ NSPACE[f(n)]
```
Queste derivano da un fatto banale:
> ogni macchina deterministica √® un **caso particolare** di macchina non deterministica (cio√® con un solo ramo).

‚úÖ **E sappiamo anche che**:
> Tutto ci√≤ che √® **decidibile da una macchina non deterministica** √® anche **decidibile da una deterministica** (concettualmente parlando).

#### ‚ùóMA...il vero problema
Supponiamo di avere una linguaggio $$L \in NTIME[f(n)]$$cio√®: esiste una macchina NON deterministica che lo decide in tempo $f(n)$
>[!bug] In questo caso non sappiamo dire
>- in quale **classe deterministica** si trova $L$
>- se c'√® una funzione $g(n)$ tale che `L ‚àà DTIME[g(n)]`
>- e non sappiamo quanto pi√π grande debba essere $g(n)$ rispetto a $f(n)$

üéØ In parole semplici:
> **Sappiamo che una macchina deterministica pu√≤ risolvere tutto ci√≤ che una non deterministica pu√≤**,  
> **ma non sappiamo quanto tempo le serve per farlo.**
> a meno che la funzione limite f della classe non sia una funzione time-constructible‚Ä¶

#### Teorema 6.17
>[!lemma] Teorema 6.17 
>![[content/Zphoto/Pasted image 20250430182029.png]]

Cio√®:  
>  Se un linguaggio √® **decidibile in tempo non deterministico $f(n)$**, allora √® anche decidibile **deterministicamente** in **tempo esponenziale** in $f(n)$.

üß† **Cosa significa e perch√© √® importante**
> Questo teorema ti risponde: **al massimo tempo $2^{O(f(n))}$**.  
> (Non sappiamo se basta meno, ma almeno abbiamo un limite superiore!)


#### ‚öôÔ∏è Come funziona la dimostrazione
##### üß© 1. Partenza
Questa parte √® molto simile a quella di prima, la copio e incollo
![[content/Zphoto/brave_GyLLY6kUww.png]]
##### üß©La macchina $T$ con input $x$ opera in due fasi
###### FASE 1) Simula la computazione $T_{f}(| x |)$
1. Scrive $1^{|x|}$ sul secondo nastro
	- Prende in input la stringa `x`
	- Conta i caratteri: `|x|`
	- Scrive `|x|` simboli `1` sul secondo nastro ‚Üí $1^{|x|}$
	
	Questo √® l'input per calcolare `f(|x|)` nella fase successiva.
 
 2. Calcola `f(|x|)` e scrive $1^{f(|x|)}$ sul terzo nastro
	- Usa una macchina trasduttrice $T_f$ che:
	  - Prende $1^{|x|}$ come input
	  - Scrive $1^{f(|x|)}$ sul terzo nastro
	- Questa computazione richiede `O(f(|x|))` passi perch√© `f` √® **time-constructible**

 3. Concatena `h` volte il contenuto del terzo nastro
	- Dal terzo nastro legge $1^{f(|x|)}$
	- Lo ripete `h` volte ottenendo: $1^{h ¬∑ f(|x|)}$
	- Questo rappresenta il limite massimo di passi ammessi per ogni computazione di `NT(x)`



**FASE 2) Simulazione delle computazioni deterministiche**
	üéØ Obiettivo
	Simulare tutte le possibili computazioni deterministiche della macchina non deterministica $NT(x)$ entro un numero massimo di passi pari a $h(f(|x|))$.

1. üîπSimula tutte le computazioni deterministiche di $NT(x)$ una per una:
	- Ogni computazione ha al massimo $h(f(|x|))$ passi.
	- Si usa un contatore sul terzo nastro con $1^{h(f(|x|))}$ in notazione unaria.
	- Le computazioni vengono simulate:
		  - da sinistra verso destra nell'albero delle scelte,
		  - una alla volta,
  - e ciascuna viene **interrotta** se supera il limite di passi.

###### ‚úÖ Correttezza: T decide L
###### ‚û§ Se $x \in L$:
- Almeno una computazione accetta entro $h(f(|x|))$ passi.
- Quindi T prima o poi simula quella computazione e accetta.
###### ‚û§ Se $x \notin L$:
- Nessuna computazione accetta entro $h(f(|x|))$ passi.
- Quindi T simula tutte le computazioni e alla fine rigetta.

‚û°Ô∏è Dunque: **T √® corretta e decide $L$**.


#### ‚è±Ô∏è Complessit√† temporale di T
#### üî∏ FASE 1:
Richiede $O(h(f(|x|)))$ passi, perch√© $f$ √® time-constructible.

#### üî∏ FASE 2:
- Sia $k$ il grado di non determinismo di $NT$ (costante).
- Il numero totale di computazioni deterministiche di lunghezza $h(f(|x|))$ √® $k^{h(f(|x|))} = 2^{O(f(|x|))}$.
- Ogni computazione richiede al pi√π $h(f(|x|))$ passi.

Quindi:
$$
\text{dtime}(T,x) \in O(h(f(|x|)) \cdot k^{h(f(|x|))}) = O(h(f(|x|)) \cdot 2^{O(f(|x|))}) \subseteq O(2^{O(f(|x|))})
$$

#### üîö Conclusione finale
Dal Teorema 6.3 (che consente di simulare una macchina a pi√π nastri con una a un nastro), possiamo dire che:
$$
L \in \text{DTIME}[2^{O(f(|x|))}]
$$

---

## Specifiche classi di complessit√†
Stiamo per introdurre alcune fra le pi√π rilevanti classi di complessit√†, definite sulla base di funzioni time- e space-constructible
![[content/Zphoto/Pasted image 20250430185127.png]]
![[content/Zphoto/Pasted image 20250430185141.png]]


### Propriet√† - Corollario 6.2
![[content/Zphoto/Pasted image 20250430185256.png]]


## üîç Relazioni tra classi di complessit√†: inclusioni improprie

>[!question] Cosa significa "inclusione impropria"?
Un'inclusione impropria √® un'inclusione tra classi di complessit√† che **non sappiamo se sia stretta oppure un'uguaglianza**.
>
Ad esempio:
>- Sappiamo che $\text{P} \subseteq \text{NP}$,  
  ma **non sappiamo se** $\text{P} = \text{NP}$ oppure $\text{P} \subset \text{NP}$.
>- Sappiamo che $\text{PSPACE} \subseteq \text{EXPTIME}$,  
  ma **non sappiamo se** $\text{PSPACE} = \text{EXPTIME}$.
>
üëâ Quindi sono **relazioni deboli**: ci dicono che una classe √® contenuta nell‚Äôaltra, ma **non quanto sia pi√π piccola** (o se lo sia davvero).

### ü§î Esempi
- Tutti i linguaggi in **PSPACE** sono anche in **EXPTIME**
- Tutti i linguaggi in **P** sono anche in **NP**

Ma **non sappiamo** se le inclusioni siano **strette** o no.


Quindi diciamo che
> Si tratta di **relazioni deboli**: ci dicono qualcosa, ma **non abbastanza** per distinguere chiaramente tra problemi facili e difficili.

>[!bug] Sarebbe problematico (per la teoria) se si dimostrasse che **tutte queste inclusioni sono in realt√† uguaglianze**, perch√©:
>- Implicherebbe che classi apparentemente pi√π potenti **non aggiungono niente di nuovo**.
>- E non potremmo pi√π classificare i problemi secondo la loro ‚Äúdifficolt√† computazionale‚Äù.


### üî¥ L‚Äôunica inclusione stretta conosciuta: Gerarchia temporale

>[!lemma] Teorema 6.15 - Teorema di gerarchia temporale
>![[content/Zphoto/Pasted image 20250430190834.png]]

‚úÖ Significato:
- Esiste un linguaggio $L$ che √® **decidibile in tempo** $f(n)$ ma **non** in $g(n)$.
	Questo perch√© $g(n)$ √® troppo pi√π piccolo (e meno potente) di $f(n)$

- Quindi $\text{DTIME}[f(n)]$ √® **strettamente pi√π potente** di $\text{DTIME}[g(n)]$.

##### üîπ Conseguenza importante: Teorema 6.18
>[!lemma] Teorema 6.18 
>$$\text{P} \subset \text{EXPTIME}$$

‚úîÔ∏è Questa √® **l‚Äôunica inclusione stretta dimostrata** tra classi standard.
	$\subset$ indica un'inclusione **propria**
Tutte le altre inclusioni (come $\text{P} \subseteq \text{NP}$) sono ancora **improprie**.


### üü£ L‚Äôunica uguaglianza dimostrata: determinismo = non determinismo nello spazio
>[!lemma] Teorema 6.19
>$$\text{PSPACE} = \text{NPSPACE}$$

üéØ Significato:
- Ogni linguaggio che pu√≤ essere **accettato** da una macchina **non deterministica** con spazio polinomiale,
- Pu√≤ essere anche **deciso** da una macchina **deterministica** con spazio polinomiale.

‚úîÔ∏è √à un caso raro: nello spazio, determinismo e non determinismo **sono equivalenti** in potenza computazionale.

