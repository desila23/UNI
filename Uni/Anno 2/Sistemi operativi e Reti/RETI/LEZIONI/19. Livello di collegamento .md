## Introduzione
#### Cosa fa il livello di collegamento?
Trasferisce i datagrammi da un nodo a quello fisico adiacente lungo un collegamento diretto.

In parole semplici:
- Se due dispositivi (es. due switch o un PC e un router) sono **direttamente collegati**,  
    il **livello di collegamento** si occupa di **trasferire i dati da uno all'altro** su quel tratto.
- Il livello 2 **non si occupa di tratte lunghe**, ma **solo del tratto locale** tra due dispositivi **fisicamente vicini**.

### ðŸ“š Terminologia
##### ðŸ”¹ **Nodi**
- Qualsiasi entitÃ  connessa alla rete: host, router, switch, ecc.

##### ðŸ”¹ **Collegamenti (link)**
- Sono i **canali di comunicazione** tra nodi **adiacenti**.
- Possono essere:
    - **Cablati** (es. Ethernet, fibra)
    - **Wireless** (es. Wi-Fi, LTE)
    - Allâ€™interno di **LAN** o WAN.

##### ðŸ”¹ **Frame**
- Ãˆ il **pacchetto del livello 2**.
- Un frame **incapsula** (cioÃ¨ contiene) un **datagramma IP** (che Ã¨ di livello 3).
- Include anche informazioni per lâ€™indirizzamento locale (es. MAC address), controllo errori, ecc.


## Esempio visivo
![[Pasted image 20250508220220.png]]


### ðŸ” Collegamenti multipli = protocolli diversi
Quando un pacchetto IP (livello 3) viaggia da un dispositivo all'altro, non viaggia tutto su un solo collegamento, ma attraversa diversi link fisici, come:
- **Wi-Fi** tra il laptop e il router di casa
- **Ethernet** tra il router e il modem
- **Fibra** tra il modem e lâ€™ISP

âž¡ï¸ **Ogni tratto Ã¨ gestito da un protocollo di collegamento diverso.**

### ðŸ§  Cosa implica?
###### 1. Diversi protocolli di livello 2
- Ogni link (collegamento) ha il suo **proprio "modo di incapsulare e trasmettere" il pacchetto**.
- Il datagramma IP viene **incapsulato in frame differenti** a seconda del tratto:
    - In casa: frame Wi-Fi
    - Verso lâ€™ISP: frame Ethernet o PPP
    - Tra router backbone: frame MPLS, ATM, ecc.

###### 2. Servizi diversi
- Alcuni protocolli offrono:
    - **AffidabilitÃ ** (con ritrasmissioni, rilevamento errori) â†’ es: Ethernet.
    - Altri no (es: Wi-Fi puÃ² essere meno affidabile, dipende dal livello MAC).
- Quindi, **non tutti i link sono "uguali" in qualitÃ  e servizi**.

![[Pasted image 20250508221724.png|center]]
Nella figura:
- I dispositivi in casa si collegano al router via **Wi-Fi**.
- Il router Ã¨ collegato al modem o a un altro nodo via **Ethernet**.
- Da lÃ¬, il pacchetto viaggia verso Internet attraverso **altri router**.


![[Pasted image 20250508221336.png]]


## Servizi offerti dal livello di collegamento
##### 1. **Framing**
> Il **frame** Ã¨ lâ€™unitÃ  di trasmissione a livello 2.

- Il **datagramma IP (livello 3)** viene **incapsulato in un frame**.
- Il frame ha:
    - Una **intestazione (header)** â†’ contiene, ad esempio, indirizzi MAC
    - Un **trailer (coda)** â†’ puÃ² includere un checksum o codice CRC per controllo errori

ðŸ“¦ Ãˆ come mettere un pacco in una scatola con etichetta per spedirlo su un tratto specifico.


##### 2. **Accesso al collegamento**
> Serve a controllare **chi puÃ² usare il mezzo trasmissivo** in un dato momento.

- In reti con **mezzo condiviso** (es. Wi-Fi, LAN con hub), piÃ¹ dispositivi vogliono trasmettere â†’ serve un **protocollo MAC** (Medium Access Control).
    - Es: CSMA/CD in Ethernet, CSMA/CA in Wi-Fi
    
- Viene gestito tramite:
    - **Indirizzi MAC** â†’ identificano **mittente e destinatario locali** (non sono indirizzi IP!)
    - Usati nei frame per capire **a chi Ã¨ destinato** il pacchetto sul collegamento

ðŸŽ¯ Obiettivo: evitare collisioni e gestire lâ€™accesso al mezzo fisico.


##### 3. **Consegna affidabile tra nodi adiacenti**
> Il livello 2 puÃ² **rilevare o correggere errori** nella trasmissione.

- **Non Ã¨ obbligatorio**: dipende dal tipo di collegamento.
- **Non si usa** con collegamenti affidabili (es. Ethernet su fibra).
- **Utile invece su canali wireless**, dove gli errori sono frequenti:
    - Wi-Fi, cellulare â†’ usano **ritrasmissioni locali**, controllo CRC, codifica FEC...

ðŸ’¡ Meglio **correggere localmente** gli errori tra nodi vicini, piuttosto che lasciare che **il livello di trasporto (es. TCP)** debba rispedire tutto dal mittente!


##### 4. **Controllo di flusso**
> Serve a **coordinare la velocitÃ  di trasmissione** tra il mittente e il ricevente **adiacenti**.

- Se il mittente invia dati troppo velocemente, il ricevente potrebbe **perdere pacchetti**.
- Il livello di collegamento puÃ² applicare **meccanismi per rallentare o fermare temporaneamente** il mittente.

ðŸ“¥ Es: in Ethernet, puÃ² esserci il meccanismo **PAUSE frame** per bloccare il traffico in ingresso.


##### 5. **Rilevazione e correzione degli errori**
> I dati su un collegamento possono essere **alterati da rumore o attenuazione** del segnale.  
> Il ricevente puÃ² rilevare e/o correggere questi errori.

Due strategie:
1. **ARQ (*Automatic Repeat reQuest*)**
	- Se rileva un errore, il ricevente **chiede la ritrasmissione** del pacchetto.
		- Molto usato in Wi-Fi, protocollo PPPâ€¦

2. **FEC (*Forward Error Correction*)**
	- Il mittente **aggiunge informazioni ridondanti** nel pacchetto (es. codici Reed-Solomon).
	- Il ricevente puÃ² **correggere lâ€™errore da solo**, **senza chiedere ritrasmissioni**.
		- Il ricevente **corregge** errori direttamente usando dati extra.
			- Usato in contesti dove le **ritrasmissioni sono costose** o impossibili (es. streaming video, satelliti, VoIP...).

ðŸ’¡ **ARQ = reazione**, **FEC = prevenzione**.


##### 6. **Half-duplex vs Full-duplex**
![[Pasted image 20250508223000.png]]
- Wi-Fi Ã¨ **half-duplex**: trasmette o riceve, non entrambi insieme.    
- Ethernet moderno (su switch) Ã¨ **full-duplex**.

ðŸ“¶ Questo incide su prestazioni, latenza e gestione delle collisioni.



## Dove si trova il livello di collegamento in un host?
> Ãˆ implementato **dall'adattatore di rete**, cioÃ¨ dalla **scheda di rete** (in inglese: **NIC â€“ Network Interface Card**).

- Ogni dispositivo connesso in rete ha una scheda di rete, che puÃ² essere:
    - Integrata (su scheda madre)
    - Esterna (USB, PCI)
    - Wireless (Wi-Fi) o cablata (Ethernet)

#### âš™ï¸ **Cosa fa la scheda di rete (NIC)?**
###### Implementa:
1. **Livello fisico (physical)** â†’ converte i bit in segnali elettrici o radio.
2. **Livello di collegamento (link)** â†’ costruisce e interpreta **frame**, applica MAC, rileva erroriâ€¦

ðŸ” La scheda lavora quindi tra **livello 1 e 2 del modello ISO/OSI**.

#### ðŸ–¥ï¸ **Come comunica con il resto del sistema?**
- La NIC Ã¨ collegata al **bus del sistema (es. PCI)**.
- Questo bus collega la **CPU**, la **memoria** e le **periferiche**, tra cui appunto la NIC.


#### Rappresentazione
![[Pasted image 20250508223538.png|center|400]]
- Le frecce blu mostrano il flusso dei dati.
- Il controller gestisce gli accessi tra la CPU e la scheda.
- I pacchetti passano dal livello applicazione (in alto) â†’ verso il basso â†’ NIC â†’ rete.


#### ðŸ”§ **Come Ã¨ fatta la NIC internamente?**
- Ãˆ una **combinazione di hardware, software e firmware**.
    - **Hardware**: circuiti che gestiscono segnale, porta fisica, buffer.
    - **Firmware**: codice che gira nella NIC per gestire il MAC, frame, CRC...
    - **Driver software**: il sistema operativo usa driver per interagire con la NIC.



### Adattatore di rete negli host
Immaginiamo questa struttura 
![[Pasted image 20250508224151.png]]
dove abbiamo
- due host
	- mittente
	- ricevente

- in entrambi
	- La parte **in alto** Ã¨ la **CPU + memoria** = software dei livelli superiori
	- La parte **in basso** Ã¨ l'**adattatore di rete**, che gestisce:
	    - **Livello di collegamento (link)**
	    - **Livello fisico (physical)**

##### ðŸ”„ **Lato mittente: cosa fa il controller NIC**
1. Riceve dalla CPU il **datagramma IP** (livello 3).
2. **Incapsula** il datagramma in un **frame**:
    - Aggiunge **header** con indirizzi MAC
    - Aggiunge **bit di controllo** per errori (CRC, checksum)
    
3. Applica:
    - **Controllo di flusso** (per non saturare il ricevente)
    - **Consegna affidabile** (se prevista)
    - **Accesso al mezzo** (decide quando trasmettere)
4. Passa il frame al **livello fisico** per trasmetterlo sul cavo o via radio.

##### ðŸ“¥ **Lato ricevente: cosa fa il controller NIC**
1. Riceve il **segnale fisico** (bit stream) e lo converte in un **frame**.
2. **Verifica** se ci sono errori (CRC).
3. Se abilitato:
    - Effettua **ritrasmissione/controllo errori**
    - Applica **controllo di flusso**
4. **Estrae il datagramma IP** dal frame.
5. Lo passa alla **CPU**, che lo consegna al **livello 3 (network)**.

>[!tip]- NOTA
>La CPU **non fa direttamente tutto il lavoro del livello 2**:
>
>- Gestisce solo le **interazioni con la NIC**, come:
>    
>    - Assemblaggio delle info di indirizzamento (MAC)
>        
>    - Scelte politiche sul trattamento degli errori
>        
>- Tutto il resto (trasferimento, codifica, controllo errori) Ã¨ **delegato alla scheda di rete**, che Ã¨ **hardware + firmware dedicato**.


---

## Rilevazione degli errori
![[GetImage - 2025-05-09T210533.046.png|center]]
`D`Â Ã¨ il blocco dei dati che vogliamo trasmettere e puÃ² contenere:Â 
- Il datagramma vero e proprio (cioÃ¨ i dati dell'utente)Â 
- Varie intestazioniÂ 
    - Chi ha mandato il pacchettoÂ 
    - Chi deve riceverloÂ 
    - AltroÂ 

Tutto questo viene protetto da `EDC` che serve per trovare gli erroriÂ 

Il mittente 
- prende `D` (*dati + intestazioni*), 
- calcola `EDC` 
- e manda tutto insieme. 
Questo blocco viaggia sul collegamento e se ci sono errori nei bit il ricevente li puÃ² scoprire grazie all'EDCÂ 

Nell'immagine sopra 
- (sinistra) abbiamo un datagramma diviso in `D+EDC` (che include i bit aggiuntivi per rilevare errori). Questo blocco viene inviato sul collegamento.Â 

- La ricezione (destra) riceve `D'+EDC'` (ci sono iÂ primoÂ perchÃ© alcuni bit possono cambiare durante la trasmissione, sono versioni modificate,) il ricevente controlla se i bit in `D'` sono ancora validi tramite `EDC'`:Â 
	- Se sÃ¬ OK i dati sono correttiÂ 
	- Se no (N) c'Ã¨ un errore e il sistema se ne accorgeÂ 

Dato che la rilevazione degli errori non Ã¨ perfetta al 100% si usano piÃ¹ bit nell'`EDC` e si fanno calcoli piÃ¹ complessi (+ overhead)


### Controllo di paritÃ 
Ãˆ un metodo semplice per rilevare e correggere errori (non sempre)

#### Bit di paritÃ  singolo
Ãˆ un **bit che il mittente aggiunge ai dati** per **verificare** se si sono verificati errori **durante la trasmissione**.

Ce ne sono due tipi:
- **ParitÃ  pari** (even parity): il numero totale di 1 **deve essere pari**
- **ParitÃ  dispari** (odd parity): il numero totale di 1 **deve essere dispari**

Ipotizza di avere questo caso (siamo nella ParitÃ  pari)
![[Pasted image 20250509211937.png|center]]
- LATO MITTENTE: Ci sono `9` bit a 1, quindi viene aggiunto un nuovo bit impostato a `1` -> cosÃ¬ sono pari
- LATO RICEVENTE: Riceve il messaggio, controlla i bit
	- se il numero di `1` Ã¨ PARI -> non ci sono stati errori
	- se il numero di `1` Ã¨ DISPARI -> ci sono stati errori

>[!bug] ATTENZIONE: questo metodo serve solo per <u>RILEVARE</u> errori, non per <u>CORREGGERLI</u>


#### ParitÃ  bidimensionale
![[Pasted image 20250509212424.png|center]]
Qui abbiamo una tabella di bit dove hai
- i dati veri e propri su ogni riga
- alla destra di ogni riga hai un ***bit di paritÃ  per la riga***
- in fondo a ogni colonna hai un ***bit di paritÃ  per la colonna***

Qui per far sÃ¬ che non ci sono errori, devo far sÃ¬ SIA riga SIA colonna non abbiano errori

âœ… **CASO *SENZA* CON ERRORE**
![[Pasted image 20250509212634.png|center]]

âŒ **CASO *CON* ERRORE**
![[Pasted image 20250509212704.png|center]]


### Limiti del controllo di paritÃ 
In genere funziona bene se gli errori sono pochi e sparsi ma nella realtÃ  spesso non Ã¨ cosÃ¬, perchÃ© possono arrivare tanti errori a gruppiÂ (*burst di errori*)Â e il controllo di paritÃ  potrebbe commettere errori.

>[!tip] ðŸ§¨ **Cosâ€™Ã¨ un errore a burst?**
Un **errore a burst** Ã¨ un gruppo di bit contigui in cui **uno o piÃ¹ bit sono sbagliati**, ma **tutti i bit tra il primo e lâ€™ultimo errore vengono considerati parte del burst**.

Esempio
![[Pasted image 20250509213134.png]]
Se vedi qui sono stati alterati 4 bit, non consecutivi.
Quindi il blocco di errore viene considerato di 7 bit (ma in realtÃ  Ã¨ 4).

>**La lunghezza del burst non Ã¨ il numero di bit errati**,  
>ma **la distanza tra il primo e lâ€™ultimo bit sbagliato**, **inclusi** i bit corretti nel mezzo.


#### Vediamo vari esempi dei limiti del controllo di paritÃ 
![[GetImage - 2025-05-09T213440.430.png|center]]
- La prima riga ha errore di paritÃ 
- La quinta colonna ha errore. 
L'incrocio ci dice esattamente il bit da correggere perÃ² nella realtÃ  gli errori sono 3, e in questo caso non si sa quale correggere.
>[!tip] Nota che addirittura la colonna 2, a seguito di due errori opposti, risulta addirittura corretta


![[GetImage - 2025-05-09T213729.892.png|center]]
Due errori sulla stessa riga rilevati su colonne differenti, ci sono 2 possibili punti di incrocio (riga 2 e colonna 2 o riga 2 e colonna 5)Â ma non sa quale dei due Ã¨ sbagliato, o se entrambi lo sono.


![[GetImage - 2025-05-09T213751.818.png|center]]
Discorso analogo a sopra ma al contrario,Â 2 bit sospettiÂ e non sappiamo quale (o se entrambi) sono sbagliati.


![[GetImage - 2025-05-09T213809.822.png|center]]
Qui addirittura abbiamo 4 punti possibili, il sistema non sa quale dei 2 correggere perchÃ© se ne cambia solo 1 sbaglia e se ne cambia 2 a caso peggiora.


![[GetImage - 2025-05-09T213828.315.png|center]]
Stesso discorso abbiamo 4 incroci ma solo 2 errori "veri". 
Il sistema non sa cosa fare.


![[GetImage - 2025-05-09T213901.294.png|center]]
Abbiamo 3 bit errati ma il sistema vede solo 1 riga sbagliata e una colonna sbagliata pensando ci sia solo 1 errore. 
In realtÃ  ci sono altri 2 errori "nascosti". Anche se solo 1 riga e 1 colonna sembrano sbagliate, con 3 erroriÂ puÃ² sembrareÂ un errore singolo ma anche correggendo il risultato sarÃ  comunque sbagliato.


![[GetImage - 2025-05-09T213938.988.png|center]]
ParitÃ  sbagliata in 3 righe e 3 colonne e quindi 9 punti sospetti, sono troppi il ricevente non sa quali dei 3 bit di errore cambiare. Se prova a correggere,Â rischia di peggiorare.


![[GetImage - 2025-05-09T213958.621.png|center]]Qui l'errore non viene neanche rilevato perchÃ© le paritÃ  risultano tutte corrette. 
==Questo Ã¨ il limite piÃ¹ graveÂ gli errori multipli, specialmente in numero pari, possono passare inosservati==.


![[GetImage - 2025-05-09T214023.810.png]]
Questa volta gli errori sono rilevati anche se ci sono 4 bit sbagliati. Ãˆ solo un caso rispetto a prima.