Riprendiamo il discorso dell'ultima lezione sulla correlazione polinomiale.
Prendi questo esempio
![[Pasted image 20250424164625.png]]
Vedi che posso andare avanti all'infinito.

Ma nella teoria della Complessità Computazionale le cose non sono proprio così.

---

## Alla ricerca della macchina più veloce
#### Teorema per `dtime`
>[!lemma] Teorema 6.7 - Accelerazione lineare
>![[Pasted image 20250424165016.png]]

Questo teorema ci dice che, dato un qualunque algoritmo, ne esiste sempre uno più veloce (di un fattore costante!).

>[!question] Perché però abbiamo i due addendi $O(|x|^{2})$ e $O(|x|)$?
>Perché per essere più efficienti, gli algoritmi devono
>- codificare in forma espressa il proprio input (vedi teorema successivo)
>	- se la codifica è scritta su un nastro apposito ($T_{2}$) allora bastano $O(|x|)$ passi
>	- se la macchia dispone di un solo nastro ($T_{1}$) allora occorrono $O(|x|^{2})$ passi

#### Teorema per `dspace`
Dimostriamo un teorema analogo a quello di prima ma per `dspace`
>[!lemma] Teorema 6.6 - Compressione lineare
>![[Pasted image 20250424170459.png]]

Anche qui, viene detto che, dato un qualunque algoritmo, ne esiste un altro che usa una frazione costante della memoria del primo

>[!question] Perché l'addendo $O(|x|)$?
>Intanto, l'input di $T_{1}$ è lo stesso di $T$.
>Pertanto $T_{1}$ deve codificare in forma compressa il proprio input e poi lavorare sull'alfabeto compresso.
>
>Osserva come l'alfabeto compresso sia $\Sigma^{k}$ (ossia, un carattere dell’alfabeto compresso è una parola di k caratteri di Σ) e che l'alfabeto di $T_{1}$ è $$\Sigma^{k} \cup \Sigma$$perché l'alfabeto originale non scompare.


---

## Classi di complessità (deterministiche)
Siamo pronti a raggruppare i linguaggi in base all'efficienza delle macchine che li decidono.

>[!question] Cosa vuol dire che una macchina che decide un linguaggio ha una certa efficienza?
>Significa che la macchina che decide un linguaggio $L \subseteq \Sigma^{*}$ si comporti "bene" su <u>ogni</u> parola $x \in \Sigma^{*}$

Però ovviamente non possiamo trovare la macchina "migliore", perché tanto sappiamo che se ne prendo una ne esisteranno altre più potenti (teoremi di prima).

Per risolvere questa questione utilizziamo la notazione $O$ e diciamo che 
	==Un linguaggio `L` appartiene all'insieme caratterizzato dalla "efficienza temporale" individuata dalla funzione totale e calcolabile `f`, se esiste una macchina `T` che decide (o accetta) `L` e che, per ogni `x` sull'alfabeto di `L`, termina in `O(f(|x|))` istruzioni.==

E discorso analogo per "efficienza spaziale".

#### Effettive classi di complessità deterministiche
##### Efficienza temporale - DTIME
Le classi che misurano "efficienza temporale" nel caso deterministico si chiamano <font color="#ff0000">DTIME</font>: data una <font color="#245bdb">funzione totale e calcolabile f</font> ![[Pasted image 20250424182246.png]]
ATTENZIONE: 
- <font color="#245bdb">dtime</font> (minuscolo) è la **misura di complessità**, ossia, una <u>funzione</u>
- <font color="#ff0000">DTIME</font> (MAIUSCOLO) è una **classe di complessità**, ossia, un <u>insieme</u>

##### Efficienza spaziale - DSPACE
Le classi che misurano "efficienza spaziale" nel caso deterministico si chiamano <font color="#ff0000">DSPACE</font>: data una <font color="#245bdb">funzione totale e calcolabile f</font> ![[Pasted image 20250424182520.png]]


---

## Classi di complessità (non deterministiche)
Facciamo le stesse considerazioni delle deterministiche.
##### Efficienza temporale - NTIME
Le classi che misurano "efficienza temporale" nel caso deterministico si chiamano <font color="#ff0000">NTIME</font>: data una <font color="#245bdb">funzione totale e calcolabile f</font> ![[Pasted image 20250424182637.png]]