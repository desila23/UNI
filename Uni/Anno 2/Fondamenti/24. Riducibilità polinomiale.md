Come abbiamo visto l'altra volta, la maggior parte delle relazioni fra classi di complessit√† sono ***inclusioni improprie*** ($\subseteq$).

>[!tip] Tranne le seguenti
>$$P \subset EXPTIME$$ $$PSPACE = NPSPACE$$

![[Pasted image 20250507173038.png]]

Le relazioni che conosciamo sono dette ***deboli***.

E, inoltre, ipotizziamo di aver dimostrato che una cerca classe di complessit√† $C_{1}$ √® contenuta propriamente in un'altra classe di complessit√† $C_{2}$ $$C_{1} \subset C_{2}$$e quindi
- ogni linguaggio in $C_{1}$ √® anche in $C_{2}$
- MA esistono linguaggi in $C_{2}$ che non sono in $C_{1}$.

>[!problem] PROBLEMA: non riusciamo a dimostrare che, se un linguaggio appartiene a $C_{2}$, allora appartiene a $C_{1}$.

Nel senso, immagina di avere un linguaggio $L$ tale che $$L \in C_{2}$$Come fai a sapere se
- $L$ √® anche in $C_{1}$?
- Oppure non lo √®, e quindi √® un **linguaggio "separatore"** tra $C_{1}$ e $C_{2}$, cio√® $$L \in C_{2} \ \backslash C_{1}$$
#### üß© Il punto chiave
> Anche se hai dimostrato che $C_{1} \subset C_{2}$,  
> **non hai uno strumento meccanico per capire se un certo linguaggio appartiene solo a $C_{2}$‚Äã** o anche a $C_{1}$‚Äã.

Cio√®: **serve qualcosa che ti aiuti a riconoscere i "linguaggi separatori"**.


---

### Un piccolo aiuto: LE RIDUZIONI ma con una piccola rivisitazione
Ripetiamo in concetto di riduzione (che non me lo ricordo)

Quando diciamo che $$L_1 ‚âº L_2$$Intendiamo che:

> Il problema $L_1$ √® riducibile a $L_2$.  
> Cio√®: possiamo risolvere $L_1$ trasformando il problema in un‚Äôistanza di $L_2$.

##### üîß Come possiamo fare?
Usiamo una funzione $f: \Sigma_1^* \rightarrow \Sigma_2^*$ tale che:
1. $f$ √® **totale e calcolabile**, ovvero:
   - √à definita per ogni parola $x \in \Sigma_1^*$
   - Esiste una **macchina di Turing trasduttore** che calcola $f(x)$ per ogni parola $x \in \Sigma_{1}^{*}$ e la scrive sul nastro di output
	   - ricordandoci che $f(x) \in \Sigma_{2}^{*}$

2. **Preserva l‚Äôappartenenza**:$$
   x \in L_1 \iff f(x) \in L_2
   $$per ogni $x \in \Sigma_{1}^{*}$

üß† Quindi: per sapere se $x \in L_1$, basta trasformare $x$ in $f(x)$ e verificare se $f(x) \in L_2$.  
√à utile per trasferire la complessit√† di un problema su un altro.


#### üü£ Riduzione rivisitata: $\pi$-riduzione
Ora si aggiunge **una richiesta extra** alla funzione $f$, espressa con un **predicato $\pi$**.

##### üîç Predicato $\pi$: una propriet√† della funzione
Sia $ùúã$ un predicato definito sull‚Äôinsieme delle funzioni totali e calcolabili ‚Äì ossia, una propriet√†, che deve essere posseduta da una funzione ad esempio: 
![[Pasted image 20250507180321.png|center]]

##### üìò Definizione di $\pi$-riduzione
Dati due linguaggi $L_{1} \subseteq \Sigma_{1}^{*}$ e $L_{2} \subseteq \Sigma_{2}^{*}$, diciamo che:
$$
L_1 ‚âº_{\pi} L_2
$$
se esiste una funzione $f$ tale che:
1. $f$ √® **totale e calcolabile**  
2. per ogni $x \in \Sigma_{1}^{*}$ vale che $x \in L_1 \iff f(x) \in L_2$  
3. $f$ soddisfa il predicato $\pi$


### Due concetti fondamentali delle $\pi$-riduzioni 
Lo strumento a cui alludevamo prima √® basato su due concetti fondamentali delle $\pi$-riduzioni
1. ***CHIUSURA*** di una <u>classe</u> rispetto a una $\pi$-riduzione
2. ***COMPLETEZZA*** di un <u>linguaggio per una classe</u> rispetto a una $\pi$-riduzione

#### *CHIUSURA*

^3170fe

>[!definizione] DEFINZIONE 6.4 - CHIUSURA
>Una classe di complessit√† $C$ √® ***chiusa*** rispetto a una generica $\pi$-riduzione se, per ogni coppia di linguaggi $L_{1}$ e $L_{2}$ tali che $$L_{1} ‚âº_{\pi} L_{2} \ \ \ \text{e} \ \ \ L_{2} \in C$$si ha che $$L_{1} \in C$$

##### üí° Perch√© √® utile?
> Serve per **dimostrare che un certo linguaggio $L$** appartiene a una classe $C$.

Basta:
- mostrare che $C$ √® chiusa per $\pi$-riduzioni,
- trovare un linguaggio $L_0 \in C$,
- e costruire una riduzione $L ‚âº_{\pi} L_0$.

Allora, automaticamente: $L \in C$


#### *COMPLETEZZA*
>[!definizione] DEFINZIONE 6.3 - COMPLETEZZA
>Sia $C$ una classe di complessit√† di linguaggi e sia $‚âº_{ùùÖ}$ una generica $ùúã$-riduzione. 
>
Un linguaggio $L \subseteq \Sigma^*$ √® $\mathcal{C}$-completo rispetto alla $\pi$-riducibilit√† se:
>- $L \in \mathcal{C}$  
>  üëâ Cio√®: $L$ appartiene alla classe di complessit√† $\mathcal{C}$
>
>- Per ogni altro linguaggio $L_0 \in \mathcal{C}$, vale che $L_0 ‚âº_{\pi} L$  
>  üëâ Ogni linguaggio della classe si pu√≤ $\pi$-ridurre a $L$

##### üß† Intuizione
Se un linguaggio √® $C$-completo:
- √à **il pi√π difficile** della classe $C$ (rispetto a $\pi$-riduzioni)
- Qualsiasi altro problema della classe pu√≤ essere trasformato in esso (quindi "contenuto" in esso)
- Se trovi un algoritmo ‚Äúfacile‚Äù per risolvere un problema completo, allora puoi risolvere **tutti** i problemi della classe!


### üß© Collegamento tra *chiusura* e *completezza*
- Se una classe $C$ √® **chiusa** rispetto a una $\pi$-riduzione
- e un linguaggio $L \in C$ √® **completo**,
- allora possiamo usare $L$ per ‚Äúrappresentare‚Äù tutta $C$.


---

## Il linguaggio "pi√π difficile" di una classe
Le nozioni di 
- completezza di un linguaggio per una classe rispetto ad una ùúã-riduzione 
- chiusura di una classe rispetto alla ùúã-riduzione 

sono gli strumenti che ci permettono di arrivare al concetto di linguaggio ‚Äô‚Äôpi√π difficile‚Äô‚Äô in una classe.

#### Proviamo a dare un'applicazione pratica
##### üìå Contesto iniziale
- due classi di complessit√† $C_{1}$ e $C_{2}$ tali che $$C_{1} \subseteq C_{2}$$
	- quindi $C_{1}$ √® "pi√π piccola" (o uguale) a $C_{2}$


##### üîê Sappiamo che $C_{1}$ √® ***chiusa*** rispetto a una qualche $\pi$-produzione
E quindi
> se $L_{1} ‚âº_{\pi} L_{2}$ e $L_{2} \in C_{1}$, allora anche $L_{1} \in C_{1}$


##### üéØ Supponiamo di trovare un linguaggio $L$ che √® **$C_{2}$‚Äã-completo**
Questo vuol dire:
1. $L \in C_{2}$
2. Per ogni altro linguaggio $L_{0} \in C_{2}$, si ha $$L_{0} ‚âº  L$$-> Tutti i problemi di $C_{2}$ si possono ridurre a $L$ 


##### üß© Ora, ipotizza di aver dimostrato che $L \in C_{1}$
Rimettiamo insieme tutte le informazioni trovate fino a ora.
- Per ogni linguaggio $L_{0} \in C_{2}$:
	- $L_{0} ‚âº  L$ (lo abbiamo visto prima)
	- $L \in C_{1}$ (lo abbiamo "dimostrato")
	- $C_{1}$ √® ***chiusa*** rispetto a una $\pi$-produzione (lo abbiamo detto all'inizio)

‚û°Ô∏è Quindi: per ogni $L_{0} \in C_{2}$, vale che $L_{0} \in C_{1}$

E, dunque $$C_{1} = C_{2}$$

![[Pasted image 20250507191437.png]]
Infatti
>[!lemma] Teorema 6.20
>Siano $\mathcal{C}$ e $\mathcal{C}_0$ due classi di complessit√† tali che $\mathcal{C}_0 \subseteq \mathcal{C}$.  
Se $\mathcal{C}_0$ √® chiusa rispetto a una $\pi$-riduzione, allora:
>- Per ogni linguaggio $L$ che √® $\mathcal{C}$-completo rispetto a $\pi$, si ha che: $$
> L \in \mathcal{C}_0 \iff \mathcal{C}_0 = \mathcal{C}
> $$
##### üß© Spiegazione passo-passo

###### ‚úÖ Caso 1: $\mathcal{C}_0 = \mathcal{C}$
Ovviamente, ogni linguaggio in $\mathcal{C}$ (incluso $L$) √® anche in $\mathcal{C}_0$.

###### üîÅ Caso 2: Supponiamo $L \in \mathcal{C}_0$
- Poich√© $L$ √® $\mathcal{C}$-completo, ogni $L' \in \mathcal{C}$ si pu√≤ $\pi$-ridurre a $L$
- Dato che $\mathcal{C}_0$ √® chiusa rispetto a $\pi$, segue che ogni $L' \in \mathcal{C}$ √® anche in $\mathcal{C}_0$
- Quindi: $\mathcal{C} = \mathcal{C}_0$


---

### Una particolare $\pi$-produzione
Dati due linguaggi, $L_{1} ‚äÜ Œ£_{1}^{*}$  e $L_{2} ‚äÜ Œ£_{2}^{*}$,
- diciamo che $L_{1}$ √® ***polinomialmente*** riducibile a $L_{2}$ 
- e scriviamo $L_{1} ‚âº_{p} L_{2}$ 
Se esiste una funzione:
$$
f : \Sigma_1^* \rightarrow \Sigma_2^*
$$

tale che:
##### 1. $f$ √® **totale e calcolabile in tempo polinomiale**
Vuol dire che:
- $f$ √® definita per ogni parola $x \in \Sigma_1^*$
- Esiste una **macchina di Turing trasduttore** $T_f$ che, dato un input $x \in \Sigma_{1}^{*}$, termina scrivendo su nastro di output il valore $f(x) \in \Sigma_{2}^{*}$
  - Esiste una **costante `c`** tale che il tempo di esecuzione √® al pi√π:
$$
\text{dtime}(T_f, x) \in O(|x|^c)
$$
	cio√® un tempo polinomiale nella lunghezza dell'input.

##### 2. $f$ **preserva l‚Äôappartenenza ai linguaggi**
Per ogni parola $x$, vale che:
$$
x \in L_1 \iff f(x) \in L_2
$$

>[!tip] DA ORA IN POI $‚âº_{p}$ lo scriveremo semplicemente come $‚âº$ 


---

## Applichiamo il nuovo strumento
##### üéØ Obiettivo
Hai due linguaggi:
- $L_1 \subseteq \Sigma_1^*$
- $L_2 \subseteq \Sigma_2^*$

E vuoi decidere se una parola $x \in L_1$.

##### üß∞ Strategia: ridurre $L_1$ a $L_2$
Supponi di sapere che:
- $L_1 ‚âº_{p} L_2$,  
	cio√® esiste una funzione (trasduttore) $T_r$, calcolabile in tempo polinomiale, tale che:
$$
x \in L_1 \iff T_r(x) \in L_2
$$

- E che $L_2 \in \text{DTIME}[f(n)]$  
	‚Üí cio√® esiste un riconoscitore $T_2$ tale che, per ogni $y ‚àà Œ£_{2}^{*}$, $T_{2}(y)$ accetta <u>se e soltanto se</u> $y ‚àà L_{2}$ e, inoltre, per ogni $y ‚àà Œ£_{2}^{*}$, $$dtime(T_{2}, y) ‚àà O( f (|y|) )$$  

##### üèó Costruzione del riconoscitore $T_1$ per $L_1$
Ora costruiamo una macchina $T_1$ che riconosce $L_1$, sfruttando $T_r$ e $T_2$.  
Funziona cos√¨:
###### ‚ú≥Ô∏è FASE 1:
- $T_1$ prende $x$ come input
- Calcola $T_r(x)$ (la trasformazione polinomiale)
- Scrive il risultato su un secondo nastro

###### ‚ú≥Ô∏è FASE 2:
- Simula $T_2$ su quel secondo nastro:
  - Se $T_2$ accetta ‚Üí anche $T_1$ accetta
  - Se $T_2$ rifiuta ‚Üí anche $T_1$ rifiuta

##### ‚úÖ Perch√© funziona?
Perch√©:
- $T_2(y)$ accetta se e solo se la parola $y$ √® in $L_2$
- Ma noi sappiamo che $x \in L_1 \iff T_r(x) \in L_2$
	dove $T_{r}(x) = y$ 

Quindi, $T_1$ accetta $x \in L_1$ esattamente quando $T_2$ accetta $T_r(x)$.
E possiamo dire che $T_{1}$ DECIDE $L_{1}$

#### ‚è± Ma quanto tempo ci mette T1T_1T1‚Äã?
##### ‚ú≥Ô∏è FASE 1: Calcolo della riduzione
Hai una funzione $f(x)$, calcolata da una macchina $T_f$, che prende $x$ e produce $y = f(x)$.  
Questa funzione √® calcolabile in tempo polinomiale, cio√®:
$$
\text{dtime}(T_f, x) \in O(|x|^c)
$$
Quindi per trasformare l'input $x$ in $y$, servono al massimo $O(|x|^c)$ passi.


##### ‚ú≥Ô∏è FASE 2: Verifica dell'appartenenza a $L_2$
Ora vuoi usare una macchina $T_2$ per verificare se $y \in L_2$.  
Il tempo che ci mette $T_2$ dipende dalla lunghezza dell'input $y$, quindi:
$$
\text{dtime}(T_2, y) \in O(f(|y|))
$$

##### üîç Ma quanto √® lungo $y = f(x)$?
Siccome:
- $f(x)$ √® calcolata in tempo polinomiale,
- e scrivere $y$ sul nastro richiede un numero di passi almeno pari alla sua lunghezza,
possiamo concludere che anche la lunghezza di $y$ √® al massimo polinomiale in $|x|$.  
Cio√®:
$$
|y| \in O(|x|^c)
$$

##### üß† E quindi?
Quando vai a calcolare:
$$
O(f(|y|)) \quad \text{(cio√® il tempo per far girare } T_2 \text{ su } y)
$$
puoi sostituire $|y|$ con $|x|^c$, perch√© $y$ √® lungo al massimo cos√¨.  
Quindi:
$$
O(f(|y|)) = O(f(|x|^c))
$$

### ‚úÖ Tempo totale
Adesso sommi le due fasi:
- Calcolare $y = f(x)$: $O(|x|^c)$  
- Verificare se $y \in L_2$: $O(f(|x|^c))$
Totale:
$$
O(|x|^c + f(|x|^c))
$$

### üßæ E come si scrive la classe?
Questo vuol dire che $L_1$ si pu√≤ decidere in tempo:
$$
L_1 \in \text{DTIME}[n^c + f(n^c)]
$$

### Conclusione su questa parte
RICAPITOLIAMO: abbiamo due linguaggi, $L_{1} ‚äÜ Œ£_{1}^{*}$  e $L_{2} ‚äÜ Œ£_{2}^{*}$,  e sappiamo che $L_{1} ‚âº L_{2}$ 

>[!tip] Grazie a quello che abbiamo visto prima, siamo riusciti a dimostrare che se $L_{2} \in P$ allora $L_{1}\in P$
>Infatti, in questo caso esiste una costante `k` tale che $$L_{2} \in \text{DTIME}[n^{k}]$$
>-> allora da quanto visto nella dimostrazione precedente $$L_{1} \in \text{DTIME}[n^{c} + (n^{c})^{k}] \subseteq P$$

Ossia abbiamo dimostrato il seguente teorema
>[!lemma] TEOREMA 6.21
>Se 
>- $L_{1} ‚âº L_{2}$  
>- e  $L_{2} \in P$  
>- $\ \Rightarrow \ L_{1} \in P$ 
>
>Ossia, il teorema dice che la classe P √® chiusa rispetto alla riducibilit√† polinomiale.

![[Pasted image 20250507210857.png]]


---

## I linguaggi NP-completi
D'ora in poi, quando si parla di **riducibilit√†**, si intende **riducibilit√† polinomiale** (e la indichiamo con ‚âº).

> Non si parler√† pi√π di $\pi$-riduzioni generiche.

>[!definizione] Diciamo che un linguaggio $L \subseteq \Sigma^{*}$ √® ***NP-completo*** (rispetto alla riducibilit√† polinomiale) se
>1. $L \in NP$
>2. per ogni altro $L_{0} \in NP$, vale che $L_{0} ‚âº L$ 

![[Pasted image 20250507211808.png]]



![[Pasted image 20250507212535.png]]